<!DOCTYPE html PUBLIC "-//IETF//DTD HTML 2.0//EN">
<HTML>
<HEAD>
<TITLE>Minh Le's DSA notebook</TITLE>
</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000" LINK="#1F00FF" ALINK="#FF0000" VLINK="#9900DD">
<A NAME="top">
<CENTER><H1><U>Minh Le's DSA notebook</U></H1></CENTER>
<H1>Table of Contents</H1>
<H2>Contest</H2>

<OL START=1>
<LI><A HREF="#file1">Template</A></LI>
<LI><A HREF="#file2">.Bashrc</A></LI>
<LI><A HREF="#file3">Troubleshoot</A></LI>
<LI><A HREF="#file4">Technical Note</A></LI>
</OL>
<H2>Data Structures</H2>

<OL START=5>
<LI><A HREF="#file5">DSU</A></LI>
<LI><A HREF="#file6">Fenwick Tree</A></LI>
<LI><A HREF="#file7">Lazy Segment Tree</A></LI>
<LI><A HREF="#file8">Trie</A></LI>
<LI><A HREF="#file9">Sparse Table</A></LI>
<LI><A HREF="#file10">Small To Large Merging</A></LI>
<LI><A HREF="#file11">Sliding Window</A></LI>
</OL>
<H2>Graph</H2>

<OL START=12>
<LI><A HREF="#file12">Dijkstra</A></LI>
<LI><A HREF="#file13">BellmanFord</A></LI>
<LI><A HREF="#file14">Floyd Warshall</A></LI>
<LI><A HREF="#file15">BFS</A></LI>
<LI><A HREF="#file16">BFS 0-1</A></LI>
<LI><A HREF="#file17">Kruskal</A></LI>
<LI><A HREF="#file18">Prim</A></LI>
<LI><A HREF="#file19">MST variants</A></LI>
<LI><A HREF="#file20">Flood Fill</A></LI>
<LI><A HREF="#file21">Bipartiteness Check</A></LI>
<LI><A HREF="#file22">Shortest Cycle</A></LI>
<LI><A HREF="#file23">Kahn Algorithm for TopoSort</A></LI>
<LI><A HREF="#file24">TopoSort using DFS</A></LI>
<LI><A HREF="#file25">DP on DAG</A></LI>
<LI><A HREF="#file26">Cycle Check</A></LI>
</OL>
<H2>Tree Algorithm</H2>

<OL START=27>
<LI><A HREF="#file27">General about tree problems</A></LI>
<LI><A HREF="#file28">Tree Diameter</A></LI>
<LI><A HREF="#file29">Finding LCA</A></LI>
<LI><A HREF="#file30">Euler Tour </A></LI>
<LI><A HREF="#file31">Binary Lifting</A></LI>
</OL>
<H2>Geometry</H2>

<OL START=32>
<LI><A HREF="#file32">Point Struct</A></LI>
<LI><A HREF="#file33">Line Struct</A></LI>
<LI><A HREF="#file34">Vector Struct</A></LI>
<LI><A HREF="#file35">Complex number</A></LI>
<LI><A HREF="#file36">Circle</A></LI>
<LI><A HREF="#file37">Quadrilaterals</A></LI>
<LI><A HREF="#file38">Triangle</A></LI>
<LI><A HREF="#file39">Polygon</A></LI>
<LI><A HREF="#file40">Convex hull</A></LI>
</OL>
<H2>Bitwise</H2>

<OL START=41>
<LI><A HREF="#file41">Bit Manipulation</A></LI>
<LI><A HREF="#file42">Optimization using Bit</A></LI>
<LI><A HREF="#file43">Other trick</A></LI>
</OL>
<H2>STL</H2>

<OL START=44>
<LI><A HREF="#file44">Vector</A></LI>
<LI><A HREF="#file45">Unordered Set</A></LI>
<LI><A HREF="#file46">Tuple</A></LI>
<LI><A HREF="#file47">String</A></LI>
<LI><A HREF="#file48">Stack</A></LI>
<LI><A HREF="#file49">Set</A></LI>
<LI><A HREF="#file50">Queue</A></LI>
<LI><A HREF="#file51">Heap (Prority Queue)</A></LI>
<LI><A HREF="#file52">Order Statistic Tree</A></LI>
<LI><A HREF="#file53">Multiset</A></LI>
<LI><A HREF="#file54">Map</A></LI>
<LI><A HREF="#file55">Deque</A></LI>
<LI><A HREF="#file56">Custom Comparators</A></LI>
</OL>
<H2>Number Theory</H2>

<OL START=57>
<LI><A HREF="#file57">ModInt template</A></LI>
<LI><A HREF="#file58">Modular Inverse</A></LI>
<LI><A HREF="#file59">Modular exponentiation</A></LI>
<LI><A HREF="#file60">Prime</A></LI>
<LI><A HREF="#file61">GCD, LCM</A></LI>
<LI><A HREF="#file62">Euler's Totient Function</A></LI>
</OL>
<H2>Combinatorics</H2>

<OL START=63>
<LI><A HREF="#file63">Binomial Coefficients</A></LI>
</OL>
<H2>Other</H2>

<OL START=64>
<LI><A HREF="#file64">Coordinate Compression</A></LI>
<LI><A HREF="#file65">Backtracking</A></LI>
</OL>
<H2>Dynamic Programming</H2>

<OL START=66>
<LI><A HREF="#file66">Coin Exchange</A></LI>
<LI><A HREF="#file67">Edit Distance</A></LI>
<LI><A HREF="#file68">Knapsack</A></LI>
<LI><A HREF="#file69">LIS</A></LI>
</OL>
<H2>Divide and Conquer</H2>

<OL START=70>
<LI><A HREF="#file70">Binary Search</A></LI>
</OL>
<HR>
<A NAME="file1">
<H1>code/contest/template.cc 1/70</H1>
[<A HREF="#top">top</A>][prev][<A HREF="#file2">next</A>]
<PRE>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;bits/stdc++.h&gt;</FONT></B>
using namespace std;

using ll = <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B>;
using pi = pair&lt;<B><FONT COLOR="#228B22">int</FONT></B>,<B><FONT COLOR="#228B22">int</FONT></B>&gt;;
using pl = pair&lt;ll,ll&gt;;
using vi = vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt;;
using vll = vector&lt;ll&gt;;
using iii = tuple&lt;<B><FONT COLOR="#228B22">int</FONT></B>, <B><FONT COLOR="#228B22">int</FONT></B>, <B><FONT COLOR="#228B22">int</FONT></B>&gt;;

#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">PB</FONT> push_back
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">MP</FONT> make_pair
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <B><FONT COLOR="#0000FF">LSOne</FONT></B>(S) ((S) &amp; -(S))
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <B><FONT COLOR="#0000FF">sz</FONT></B>(x) int((x).size())
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <B><FONT COLOR="#0000FF">all</FONT></B>(x) begin(x), end(x)
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">tcT</FONT> template&lt;class T

#<B><FONT COLOR="#5F9EA0">define</FONT></B> <B><FONT COLOR="#0000FF">FOR</FONT></B>(i,a,b) for(int i=(a),_b=(b); i&lt;=_b; i++)
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <B><FONT COLOR="#0000FF">FORD</FONT></B>(i,a,b) for(int i=(a),_b=(b); i&gt;=_b; i--)
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <B><FONT COLOR="#0000FF">REP</FONT></B>(i,a) for(int i=0,_a=(a); i&lt;_a; i++)
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <B><FONT COLOR="#0000FF">DEBUG</FONT></B>(x) { cout &lt;&lt; #x &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; = &quot;</FONT></B>; cout &lt;&lt; (x) &lt;&lt; endl; }
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <B><FONT COLOR="#0000FF">PR</FONT></B>(a,n) { cout &lt;&lt; #a &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; = &quot;</FONT></B>; FOR(_,1,n) cout &lt;&lt; a[_] &lt;&lt; <B><FONT COLOR="#BC8F8F">' '</FONT></B>; cout &lt;&lt; endl; }
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <B><FONT COLOR="#0000FF">PR0</FONT></B>(a,n) { cout &lt;&lt; #a &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; = &quot;</FONT></B>; REP(_,n) cout &lt;&lt; a[_] &lt;&lt; <B><FONT COLOR="#BC8F8F">' '</FONT></B>; cout &lt;&lt; endl; }

<I><FONT COLOR="#B22222">// const int dx[4]{1,0,-1,0}, dy[4]{0,1,0,-1}; // for every grid problem!!
</FONT></I>
tcT&gt; using pqg = priority_queue&lt;T,vector&lt;T&gt;,greater&lt;T&gt;&gt;; <I><FONT COLOR="#B22222">// minheap
</FONT></I>
tcT&gt; <B><FONT COLOR="#228B22">bool</FONT></B> ckmin(T&amp; a, <B><FONT COLOR="#228B22">const</FONT></B> T&amp; b) {
	<B><FONT COLOR="#A020F0">return</FONT></B> b &lt; a ? a = b, 1 : 0; } <I><FONT COLOR="#B22222">// set a = min(a,b)
</FONT></I>tcT&gt; <B><FONT COLOR="#228B22">bool</FONT></B> ckmax(T&amp; a, <B><FONT COLOR="#228B22">const</FONT></B> T&amp; b) {
	<B><FONT COLOR="#A020F0">return</FONT></B> a &lt; b ? a = b, 1 : 0; } <I><FONT COLOR="#B22222">// set a = max(a,b)
</FONT></I>
tcT&gt; T gcd(T a, T b){ T r; <B><FONT COLOR="#A020F0">while</FONT></B> (b != 0) { r = a % b; a = b; b = r; } <B><FONT COLOR="#A020F0">return</FONT></B> a;}
tcT&gt; T lcm(T a, T b) { <B><FONT COLOR="#A020F0">return</FONT></B> a / gcd(a, b) * b; }

ll <B><FONT COLOR="#0000FF">cdiv</FONT></B>(ll a, ll b) { <B><FONT COLOR="#A020F0">return</FONT></B> a/b+((a^b)&gt;0&amp;&amp;a%b); } <I><FONT COLOR="#B22222">// divide a by b rounded up
</FONT></I>ll <B><FONT COLOR="#0000FF">fdiv</FONT></B>(ll a, ll b) { <B><FONT COLOR="#A020F0">return</FONT></B> a/b-((a^b)&lt;0&amp;&amp;a%b); } <I><FONT COLOR="#B22222">// divide a by b rounded down
</FONT></I>
tcT&gt; T gcd(T a, T b){ T r; <B><FONT COLOR="#A020F0">while</FONT></B> (b != 0) { r = a % b; a = b; b = r; } <B><FONT COLOR="#A020F0">return</FONT></B> a;}
tcT&gt; T lcm(T a, T b) { <B><FONT COLOR="#A020F0">return</FONT></B> a / gcd(a, b) * b; }

<I><FONT COLOR="#B22222">// bitwise ops
</FONT></I>constexpr <B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">pct</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> x) { <B><FONT COLOR="#A020F0">return</FONT></B> __builtin_popcount(x); } <I><FONT COLOR="#B22222">// # of bits set
</FONT></I>constexpr <B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">bits</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> x) { <I><FONT COLOR="#B22222">// assert(x &gt;= 0); 
</FONT></I>	<B><FONT COLOR="#A020F0">return</FONT></B> x == 0 ? 0 : 31-__builtin_clz(x); } <I><FONT COLOR="#B22222">// floor(log2(x)) 
</FONT></I>constexpr <B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">p2</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> x) { <B><FONT COLOR="#A020F0">return</FONT></B> 1&lt;&lt;x; }
constexpr <B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">msk2</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> x) { <B><FONT COLOR="#A020F0">return</FONT></B> p2(x)-1; }

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>()
{
    <B><FONT COLOR="#5F9EA0">ios_base</FONT></B>::sync_with_stdio(false);
    cin.tie(nullptr);


    <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}</PRE>
<HR>
<A NAME="file2">
<H1>code/contest/bashrc.txt 2/70</H1>
[<A HREF="#top">top</A>][<A HREF="#file1">prev</A>][<A HREF="#file3">next</A>]
<PRE>
alias c='g++ -Wall -Wconversion -Wfatal-errors -g -std=c++17 \
	-fsanitize=undefined,address'
xmodmap -e 'clear lock' -e 'keycode 66=less greater' #caps = &lt;&gt;

g++ -std=c++17 -O2 name.cpp -o name -Wall

open ~/.zshrc and copy: 
co() { g++ -std=c++17 -O2 -o &quot;${1%.*}&quot; $1 -Wall; }
run() { co $1 &amp;&amp; ./${1%.*} &amp; fg; }

run name.cpp // compile and run</PRE>
<HR>
<A NAME="file3">
<H1>code/contest/troubleshoot.txt 3/70</H1>
[<A HREF="#top">top</A>][<A HREF="#file2">prev</A>][<A HREF="#file4">next</A>]
<PRE>
Pre-submit:
Write a few simple test cases if sample is not enough.
Are time limits close? If so, generate max cases.
Is the memory usage fine?
Could anything overflow?
Make sure to submit the right file.

Wrong answer:
Print your solution! Print debug output, as well.
Are you clearing all data structures between test cases?
Can your algorithm handle the whole range of input?
Read the full problem statement again.
Do you handle all corner cases correctly?
Have you understood the problem correctly?
Any uninitialized variables?
Any overflows?
Confusing N and M, i and j, etc.?
Are you sure your algorithm works?
What special cases have you not thought of?
Are you sure the STL functions you use work as you think?
Add some assertions, maybe resubmit.
Create some testcases to run your algorithm on.
Go through the algorithm for a simple case.
Go through this list again.
Explain your algorithm to a teammate.
Ask the teammate to look at your code.
Go for a small walk, e.g. to the toilet.
Is your output format correct? (including whitespace)
Rewrite your solution from the start or let a teammate do it.

Runtime error:
Have you tested all corner cases locally?
Any uninitialized variables?
Are you reading or writing outside the range of any vector?
Any assertions that might fail?
Any possible division by 0? (mod 0 for example)
Any possible infinite recursion?
Invalidated pointers or iterators?
Are you using too much memory?
Debug with resubmits (e.g. remapped signals, see Various).

Time limit exceeded:
Do you have any possible infinite loops?
What is the complexity of your algorithm?
Are you copying a lot of unnecessary data? (References)
How big is the input and output? (consider scanf)
Avoid vector, map. (use arrays/unordered_map)
What do your teammates think about your algorithm?

Memory limit exceeded:
What is the max amount of memory your algorithm should need?
Are you clearing all data structures between test cases?
</PRE>
<HR>
<A NAME="file4">
<H1>code/contest/technical.txt 4/70</H1>
[<A HREF="#top">top</A>][<A HREF="#file3">prev</A>][<A HREF="#file5">next</A>]
<PRE>
Submission : 
All program source code files and/or test data files which you create must be located in or
beneath your home directory. Your home directory will normally be named /home/team
but this may vary between sites so check with your site coordinator. You may create
subdirectories beneath your home directory.

If your program exits with a non-zero exit code, it will be judged as a Run Time Error.
-----------
Compiling :
1. For C++:
compileg++ progname.cpp (compiling)
To execute a C/C++ program after compiling it as above, type the command : ./a.out

2. For Java:
compilejava Progname.java
runjava Progname

3. For python3
compilepython3 progname.py
runpython3 progname.py
----------
IDE: They can be accessed using the Applications Programming menu.
Other editors: They can be accessed using the Applications Accessories menu.</PRE>
<HR>
<A NAME="file5">
<H1>code/data structure/dsu.cc 5/70</H1>
[<A HREF="#top">top</A>][<A HREF="#file4">prev</A>][<A HREF="#file6">next</A>]
<PRE>
<I><FONT COLOR="#B22222">/**
 * Description: Disjoint-set data structure.
 * Time: O(alpha(N)), almost constant
 */</FONT></I>

<B><FONT COLOR="#228B22">struct</FONT></B> DSU {
    vi lab;
    DSU(<B><FONT COLOR="#228B22">int</FONT></B> n) { lab = vi(n, -1); }

    <I><FONT COLOR="#B22222">// get representive component (uses path compression)
</FONT></I>    <B><FONT COLOR="#228B22">int</FONT></B> get(<B><FONT COLOR="#228B22">int</FONT></B> x) { <B><FONT COLOR="#A020F0">return</FONT></B> lab[x] &lt; 0 ? x : lab[x] = get(lab[x]); }

    <B><FONT COLOR="#228B22">bool</FONT></B> same_set(<B><FONT COLOR="#228B22">int</FONT></B> a, <B><FONT COLOR="#228B22">int</FONT></B> b) { <B><FONT COLOR="#A020F0">return</FONT></B> get(a) == get(b); }

    <B><FONT COLOR="#228B22">bool</FONT></B> unite(<B><FONT COLOR="#228B22">int</FONT></B> x, <B><FONT COLOR="#228B22">int</FONT></B> y) {  <I><FONT COLOR="#B22222">// union by size
</FONT></I>		x = get(x), y = get(y);
		<B><FONT COLOR="#A020F0">if</FONT></B> (x == y) <B><FONT COLOR="#A020F0">return</FONT></B> false;
		<B><FONT COLOR="#A020F0">if</FONT></B> (lab[x] &gt; lab[y]) swap(x, y);
		lab[x] += lab[y];
		lab[y] = x;
		<B><FONT COLOR="#A020F0">return</FONT></B> true;
	}
};

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {
    DSU dsu(node_num);
    <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}

<I><FONT COLOR="#B22222">// Reverse query technique
</FONT></I><B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> N = 1e5 + 5;
<B><FONT COLOR="#228B22">int</FONT></B> n, ans;
<B><FONT COLOR="#228B22">int</FONT></B> a[N], p[N], res[N];
<B><FONT COLOR="#228B22">bool</FONT></B> flag[N];

<B><FONT COLOR="#228B22">struct</FONT></B> DSU{
    vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; parent, sz, sum;

    DSU(<B><FONT COLOR="#228B22">int</FONT></B> n) : parent(n), sz(n), sum(n) {};

    <B><FONT COLOR="#228B22">void</FONT></B> make_set(<B><FONT COLOR="#228B22">int</FONT></B> v) {
        parent[v] = v;
        sz[v] = 1;
        sum[v] = a[v];
    }
     
    <B><FONT COLOR="#228B22">int</FONT></B> find_set(<B><FONT COLOR="#228B22">int</FONT></B> v) {
        <B><FONT COLOR="#A020F0">return</FONT></B> v == parent[v] ? v : parent[v] = find_set(parent[v]);
    }

    <B><FONT COLOR="#228B22">void</FONT></B> join_sets(<B><FONT COLOR="#228B22">int</FONT></B> a, <B><FONT COLOR="#228B22">int</FONT></B> b) {
        a = find_set(a);
        b = find_set(b);
        <B><FONT COLOR="#A020F0">if</FONT></B> (a != b) {
            <B><FONT COLOR="#A020F0">if</FONT></B> (sz[a] &lt; sz[b]) swap(a,b);
            parent[b] = a;
            sz[a] += sz[b];
            sum[a] += sum[b];
        }
    }
};

<B><FONT COLOR="#228B22">signed</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {
        
    <B><FONT COLOR="#5F9EA0">ios_base</FONT></B>::sync_with_stdio(false); cin.tie(NULL);

    cin &gt;&gt; n;
    
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 1; i &lt;= n; i++) cin &gt;&gt; a[i];
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 1; i &lt;= n; i++) cin &gt;&gt; p[i];

    DSU g(n + 5);
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 1; i &lt;= n; i++) g.make_set(i);    
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = n; i &gt;= 1; i--) {
        flag[p[i]] = true;

        <B><FONT COLOR="#A020F0">if</FONT></B> (p[i] &gt; 1 &amp;&amp; flag[p[i] - 1]) g.join_sets(p[i], p[i] - 1);
        <B><FONT COLOR="#A020F0">if</FONT></B> (p[i] &lt; n &amp;&amp; flag[p[i] + 1]) g.join_sets(p[i], p[i] + 1);

        ans = max(ans, g.sum[g.find_set(p[i])]);
        res[i - 1] = ans;
    }
        
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 1; i &lt;= n; i++) cout &lt;&lt; res[i] &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;\n&quot;</FONT></B>;
        
}</PRE>
<HR>
<A NAME="file6">
<H1>code/data structure/fenwick.cc 6/70</H1>
[<A HREF="#top">top</A>][<A HREF="#file5">prev</A>][<A HREF="#file7">next</A>]
<PRE>
<I><FONT COLOR="#B22222">/**
 * Description: Computes partial sums a[0] + a[1] + ... + a[pos - 1], 
 * and updates single elements a[i],
 * taking the difference between the old and new value.
 * Time: Both operations are $O(log N)$.
 */</FONT></I>

<I><FONT COLOR="#B22222">// 0 based index
</FONT></I><B><FONT COLOR="#228B22">template</FONT></B>&lt;
    typename T  
&gt; <B><FONT COLOR="#228B22">struct</FONT></B> FT {
    FT(<B><FONT COLOR="#228B22">int</FONT></B> _n) : n(_n), f(_n + 1) {}

    <I><FONT COLOR="#B22222">// a[u] += val
</FONT></I>    <B><FONT COLOR="#228B22">void</FONT></B> update(<B><FONT COLOR="#228B22">int</FONT></B> u, T val) {
        assert(0 &lt;= u &amp;&amp; u &lt; n);
        ++u;
        <B><FONT COLOR="#A020F0">for</FONT></B> (; u &lt;= n; u += u &amp; -u) {
            f[u] += val;
        }
    }

    <I><FONT COLOR="#B22222">// return a[0] + .. + a[u-1]
</FONT></I>    T get(<B><FONT COLOR="#228B22">int</FONT></B> u) <B><FONT COLOR="#228B22">const</FONT></B> {
        assert(0 &lt;= u &amp;&amp; u &lt;= n);
        T res = 0;
        <B><FONT COLOR="#A020F0">for</FONT></B> (; u &gt; 0; u -= u &amp; -u) {
            res += f[u];
        }
        <B><FONT COLOR="#A020F0">return</FONT></B> res;
    }

    <I><FONT COLOR="#B22222">// return a[l] + .. + a[r-1]
</FONT></I>    T get(<B><FONT COLOR="#228B22">int</FONT></B> l, <B><FONT COLOR="#228B22">int</FONT></B> r) <B><FONT COLOR="#228B22">const</FONT></B> {
        assert(0 &lt;= l &amp;&amp; l &lt;= r &amp;&amp; r &lt;= n);
        <B><FONT COLOR="#A020F0">if</FONT></B> (l == r) <B><FONT COLOR="#A020F0">return</FONT></B> 0;  <I><FONT COLOR="#B22222">// empty
</FONT></I>        <B><FONT COLOR="#A020F0">return</FONT></B> get(r) - get(l);
    }

    <B><FONT COLOR="#228B22">void</FONT></B> reset() {
        <B><FONT COLOR="#5F9EA0">std</FONT></B>::fill(f.begin(), f.end(), T(0));
    }

    <B><FONT COLOR="#228B22">int</FONT></B> lower_bound(T sum) {<I><FONT COLOR="#B22222">// min pos st sum of [0, pos] &gt;= sum
</FONT></I>		<I><FONT COLOR="#B22222">// Returns n if no sum is &gt;= sum, or -1 if empty sum is.
</FONT></I>		<B><FONT COLOR="#A020F0">if</FONT></B> (sum &lt;= 0) <B><FONT COLOR="#A020F0">return</FONT></B> -1;
		<B><FONT COLOR="#228B22">int</FONT></B> pos = 0;
		<B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> pw = 1 &lt;&lt; 25; pw; pw &gt;&gt;= 1) {
			<B><FONT COLOR="#A020F0">if</FONT></B> (pos + pw &lt;= sz(f) &amp;&amp; f[pos + pw-1] &lt; sum)
				pos += pw, sum -= f[pos-1];
		}
		<B><FONT COLOR="#A020F0">return</FONT></B> pos;
	}

    <B><FONT COLOR="#228B22">int</FONT></B> n;
    vector&lt;T&gt; f;
};

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B> () {
    FT&lt;ll&gt; ft(n);
}
</PRE>
<HR>
<A NAME="file7">
<H1>code/data structure/lazysegtree.cc 7/70</H1>
[<A HREF="#top">top</A>][<A HREF="#file6">prev</A>][<A HREF="#file8">next</A>]
<PRE>
<I><FONT COLOR="#B22222">/**
 * Description: Segment Tree with lazy propagation
 */</FONT></I>

<I><FONT COLOR="#B22222">// everything should be 1-based index
</FONT></I>
<I><FONT COLOR="#B22222">// 1 x y val: Increase all elements in [x, y] by val
</FONT></I><I><FONT COLOR="#B22222">// 2 x y: max value in [x, y]
</FONT></I>
<B><FONT COLOR="#228B22">struct</FONT></B> SegTree {
    <B><FONT COLOR="#228B22">int</FONT></B> n;  <I><FONT COLOR="#B22222">// size of A
</FONT></I>    vi A, st, lazy;

    SegTree(<B><FONT COLOR="#228B22">int</FONT></B> sz) : n(sz), st(4 * n), lazy(4 * n, 0) {}

    SegTree(<B><FONT COLOR="#228B22">const</FONT></B> vi&amp; initialA, <B><FONT COLOR="#228B22">int</FONT></B> a_size): SegTree(a_size) {
        A = initialA;
        build(1, 1, n);
    }

    <B><FONT COLOR="#228B22">void</FONT></B> build(<B><FONT COLOR="#228B22">int</FONT></B> id, <B><FONT COLOR="#228B22">int</FONT></B> l, <B><FONT COLOR="#228B22">int</FONT></B> r) { <I><FONT COLOR="#B22222">// O(n)
</FONT></I>        <B><FONT COLOR="#A020F0">if</FONT></B> (l == r) {
            st[id] = A[l];
            <B><FONT COLOR="#A020F0">return</FONT></B>;
        }
        <B><FONT COLOR="#228B22">int</FONT></B> mid = (l + r) &gt;&gt; 1;
        build(2 * id, l, mid);
        build(2 * id + 1, mid + 1, r);
        st[id] = max(st[2 * id], st[2 * id + 1]); 
    }

    <I><FONT COLOR="#B22222">// propagate
</FONT></I>    <B><FONT COLOR="#228B22">void</FONT></B> fix(<B><FONT COLOR="#228B22">int</FONT></B> id, <B><FONT COLOR="#228B22">int</FONT></B> l, <B><FONT COLOR="#228B22">int</FONT></B> r) {
        <B><FONT COLOR="#A020F0">if</FONT></B> (!lazy[id]) <B><FONT COLOR="#A020F0">return</FONT></B>; 
        st[id] += lazy[id]; <I><FONT COLOR="#B22222">// careful about how to update info from lazy to node
</FONT></I>    
        <B><FONT COLOR="#A020F0">if</FONT></B> (l != r){ <I><FONT COLOR="#B22222">// if not a leaf then propagate downwards
</FONT></I>            lazy[2 * id] += lazy[id];
            lazy[2 * id + 1] += lazy[id];
        }
        <B><FONT COLOR="#A020F0">else</FONT></B> {
            A[l] += lazy[id]; 
        }
    
        lazy[id] = 0; <I><FONT COLOR="#B22222">// erase lazy flag
</FONT></I>    }

    <B><FONT COLOR="#228B22">void</FONT></B> update(<B><FONT COLOR="#228B22">int</FONT></B> id, <B><FONT COLOR="#228B22">int</FONT></B> l, <B><FONT COLOR="#228B22">int</FONT></B> r, <B><FONT COLOR="#228B22">int</FONT></B> u, <B><FONT COLOR="#228B22">int</FONT></B> v, <B><FONT COLOR="#228B22">int</FONT></B> val) { <I><FONT COLOR="#B22222">// O(log n)
</FONT></I>        fix(id, l, r);
        <B><FONT COLOR="#A020F0">if</FONT></B> (l &gt; v || r &lt; u) <B><FONT COLOR="#A020F0">return</FONT></B>;
        <B><FONT COLOR="#A020F0">if</FONT></B> (l &gt;= u &amp;&amp; r &lt;= v) {
            lazy[id] += val;
            fix(id, l, r);
            <B><FONT COLOR="#A020F0">return</FONT></B>;
        }
        <B><FONT COLOR="#228B22">int</FONT></B> mid = (l + r) &gt;&gt; 1;
        update(2 * id, l, mid, u, v, val);
        update(2 * id + 1, mid + 1, r, u, v, val);
        st[id] = max(st[2 * id], st[2 * id + 1]);
    }

    <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> get(<B><FONT COLOR="#228B22">int</FONT></B> id, <B><FONT COLOR="#228B22">int</FONT></B> l, <B><FONT COLOR="#228B22">int</FONT></B> r, <B><FONT COLOR="#228B22">int</FONT></B> u, <B><FONT COLOR="#228B22">int</FONT></B> v) { <I><FONT COLOR="#B22222">// O(log n)
</FONT></I>        fix(id, l, r);
        <B><FONT COLOR="#A020F0">if</FONT></B> (l &gt;  v || r &lt;  u) <B><FONT COLOR="#A020F0">return</FONT></B> -inf;
        <B><FONT COLOR="#A020F0">if</FONT></B> (l &gt;= u &amp;&amp; r &lt;= v) <B><FONT COLOR="#A020F0">return</FONT></B> st[id];

        <B><FONT COLOR="#228B22">int</FONT></B> mid = (l + r) &gt;&gt; 1;
        <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> get1 = get(2 * id, l, mid, u, v);
        <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> get2 = get(2 * id + 1, mid + 1, r, u, v);
        <B><FONT COLOR="#A020F0">return</FONT></B> max(get1, get2);
    }

    <B><FONT COLOR="#228B22">void</FONT></B> update(<B><FONT COLOR="#228B22">int</FONT></B> u, <B><FONT COLOR="#228B22">int</FONT></B> v, <B><FONT COLOR="#228B22">int</FONT></B> val) { update(1, 1, n, u, v, val); }
    <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> get(<B><FONT COLOR="#228B22">int</FONT></B> u, <B><FONT COLOR="#228B22">int</FONT></B> v) { <B><FONT COLOR="#A020F0">return</FONT></B> get(1, 1, n, u, v); }
};

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>()
{
    cin &gt;&gt; n &gt;&gt; m;
    vll A(n + 1, 0);
    SegTree st(A, n);

    <B><FONT COLOR="#A020F0">while</FONT></B> (m--) {
        <B><FONT COLOR="#228B22">int</FONT></B> t; cin &gt;&gt; t;
        <B><FONT COLOR="#A020F0">if</FONT></B> (t == 0) {
            <B><FONT COLOR="#228B22">int</FONT></B> u, v, val;
            cin &gt;&gt; u &gt;&gt; v &gt;&gt; val;
            st.update(u, v, val);
        }
        <B><FONT COLOR="#A020F0">else</FONT></B> {
            <B><FONT COLOR="#228B22">int</FONT></B> x, y;
            cin &gt;&gt; x &gt;&gt; y;
            cout &lt;&lt; st.get(x, y) &lt;&lt; endl;
        }
    }
    
    <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}</PRE>
<HR>
<A NAME="file8">
<H1>code/data structure/trie.cc 8/70</H1>
[<A HREF="#top">top</A>][<A HREF="#file7">prev</A>][<A HREF="#file9">next</A>]
<PRE>
<I><FONT COLOR="#B22222">/**
 * Description: Prefix tree
 * Time: Both operations are O(string length).
 */</FONT></I>

<B><FONT COLOR="#228B22">struct</FONT></B> Trie {
    <B><FONT COLOR="#228B22">struct</FONT></B> Node {
        Node* child[26];
        <B><FONT COLOR="#228B22">int</FONT></B> exist, cnt;

        Node() {
            <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; 26; i++) child[i] = NULL;
            exist = cnt = 0;
        }
    };

    <B><FONT COLOR="#228B22">int</FONT></B> cur;
    Node* root;
    Trie() : cur(0) {
        root = <B><FONT COLOR="#A020F0">new</FONT></B> Node();
    };

    <B><FONT COLOR="#228B22">void</FONT></B> add_string(string s) {
        Node* p = root;
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">auto</FONT></B> f : s) {
            <B><FONT COLOR="#228B22">int</FONT></B> c = f - <B><FONT COLOR="#BC8F8F">'a'</FONT></B>;
            <B><FONT COLOR="#A020F0">if</FONT></B> (p-&gt;child[c] == NULL) p-&gt;child[c] = <B><FONT COLOR="#A020F0">new</FONT></B> Node();
            p = p-&gt;child[c];
            p-&gt;cnt++;
        }
        p-&gt;exist++;
    }

    <B><FONT COLOR="#228B22">bool</FONT></B> delete_string_recursive(Node* p, string&amp; s, <B><FONT COLOR="#228B22">int</FONT></B> i) {
        <B><FONT COLOR="#A020F0">if</FONT></B> (i != (<B><FONT COLOR="#228B22">int</FONT></B>)s.size()) {
            <B><FONT COLOR="#228B22">int</FONT></B> c = s[i] - <B><FONT COLOR="#BC8F8F">'a'</FONT></B>;
            <B><FONT COLOR="#228B22">bool</FONT></B> isChildDeleted = delete_string_recursive(p-&gt;child[c], s, i + 1);
            <B><FONT COLOR="#A020F0">if</FONT></B> (isChildDeleted) p-&gt;child[c] = NULL;
        }
        <B><FONT COLOR="#A020F0">else</FONT></B> p-&gt;exist--;

        <B><FONT COLOR="#A020F0">if</FONT></B> (p != root) {
            p-&gt;cnt--;
            <B><FONT COLOR="#A020F0">if</FONT></B> (p-&gt;cnt == 0) {
                <B><FONT COLOR="#A020F0">delete</FONT></B>(p); 
                <B><FONT COLOR="#A020F0">return</FONT></B> true;
            }
        }
        <B><FONT COLOR="#A020F0">return</FONT></B> false;
    }

    <B><FONT COLOR="#228B22">void</FONT></B> delete_string(string s) {
        <B><FONT COLOR="#A020F0">if</FONT></B> (find_string(s) == false) <B><FONT COLOR="#A020F0">return</FONT></B>;

        delete_string_recursive(root, s, 0);
    }

    <B><FONT COLOR="#228B22">bool</FONT></B> find_string(string s) {
        Node* p = root;
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">auto</FONT></B> f : s) {
            <B><FONT COLOR="#228B22">int</FONT></B> c = f - <B><FONT COLOR="#BC8F8F">'a'</FONT></B>;
            <B><FONT COLOR="#A020F0">if</FONT></B> (p-&gt;child[c] == NULL) <B><FONT COLOR="#A020F0">return</FONT></B> false;
            p = p-&gt;child[c];
        }
        <B><FONT COLOR="#A020F0">return</FONT></B> (p-&gt;exist != 0);
    }

    <B><FONT COLOR="#228B22">void</FONT></B> dfs(Node* p, string&amp; cur_string, vector&lt;string&gt;&amp; res) {
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; 26; i++) {
            <B><FONT COLOR="#A020F0">if</FONT></B> (p-&gt;child[i] != NULL) {
                cur_string += <B><FONT COLOR="#228B22">char</FONT></B>(i + <B><FONT COLOR="#BC8F8F">'a'</FONT></B>);
                dfs(p-&gt;child[i], cur_string, res);
                cur_string.pop_back();
            }
        }
    }

    vector&lt;string&gt; sorted_strings() {
        vector&lt;string&gt; res;
        string current_string = <B><FONT COLOR="#BC8F8F">&quot;&quot;</FONT></B>;
        dfs(0, current_string, res);
        <B><FONT COLOR="#A020F0">return</FONT></B> res;
    }
};
</PRE>
<HR>
<A NAME="file9">
<H1>code/data structure/sparsetable.cc 9/70</H1>
[<A HREF="#top">top</A>][<A HREF="#file8">prev</A>][<A HREF="#file10">next</A>]
<PRE>
<I><FONT COLOR="#B22222">/**
 * Description: Sparse Table. LG la so lon nhat thoa 2^LG &lt; N. 
 * vi du: N = 10^5 thi LG = 16 vi 2^16 = 65536
 */</FONT></I>


<I><FONT COLOR="#B22222">// a is 1-based index
</FONT></I><B><FONT COLOR="#228B22">int</FONT></B> a[N], st[LG + 1][N];
<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">preprocess</FONT></B>() {
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 1; i &lt;= n; ++i) st[0][i] = a[i];
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 1; j &lt;= LG; ++j)
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 1; i + (1 &lt;&lt; j) - 1 &lt;= n; ++i)
            st[j][i] = min(st[j - 1][i], st[j - 1][i + (1 &lt;&lt; (j - 1))]);
}
<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">queryMin</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> l, <B><FONT COLOR="#228B22">int</FONT></B> r) {
    <B><FONT COLOR="#228B22">int</FONT></B> k = __lg(r - l + 1);
    <B><FONT COLOR="#A020F0">return</FONT></B> min(st[k][l], st[k][r - (1 &lt;&lt; k) + 1]);
}

<I><FONT COLOR="#B22222">// Preprocessing: O(NlogN)
</FONT></I><I><FONT COLOR="#B22222">// query: O(1)
</FONT></I><I><FONT COLOR="#B22222">// __lg(x) = floor(log_2(x)) while log2(x) return double
</FONT></I></PRE>
<HR>
<A NAME="file10">
<H1>code/data structure/smalltolarge.cc 10/70</H1>
[<A HREF="#top">top</A>][<A HREF="#file9">prev</A>][<A HREF="#file11">next</A>]
<PRE>
<I><FONT COLOR="#B22222">/**
 * Description: Small-to-large merging technique to speed up the process of merging to data structure
 */</FONT></I>

<I><FONT COLOR="#B22222">/*
Note that swap exchanges two sets in O(1) time. Thus, merging a smaller set of size m into 
the larger one of size n takes O(mlogn) time. We can also merge other standard library data structures 
such as std::map or std:unordered_map in the same way. However, std::swap does not always 
run in O(1) time. For example, swapping std::array s takes time linear in the sum of the sizes 
of the arrays, and the same goes for GCC policy-based data structures such as 
__gnu_pbds::tree or __gnu_pbds::gp_hash_table. To swap two policy-based data structures a and b 
in O(1), use a.swap(b) instead. Note that for standard library data structures, swap(a,b) 
is equivalent to a.swap(b) .
*/</FONT></I>

<I><FONT COLOR="#B22222">// Always merge smaller set to larger set
</FONT></I><B><FONT COLOR="#0000FF">if</FONT></B> (a.size() &lt; b.size()) swap(a, b);
<B><FONT COLOR="#0000FF">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> x : b) a.insert(x);

</PRE>
<HR>
<A NAME="file11">
<H1>code/data structure/slidingwindow.cc 11/70</H1>
[<A HREF="#top">top</A>][<A HREF="#file10">prev</A>][<A HREF="#file12">next</A>]
<PRE>
<I><FONT COLOR="#B22222">/**
 * Description: A sliding window is a constant-size subarray that moves 
 * from left to right through the array.
 * 
 * The most straightforward way to do this is to store an sorted set of integers 
 * representing the integers inside the window. If the window currently spans the 
 * range i...j, we observe that moving the range forward to i+1...j+1 only removes 
 * a[i] and adds a[j + 1] to the window. We can support these two operations and 
 * query for the minimum / maximum in the set in O(logN)
 */</FONT></I>

vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; maxSlidingWindow(vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; &amp;nums, <B><FONT COLOR="#228B22">int</FONT></B> k) {
	multiset&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; s;
	vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; ret;
	<B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; k; i++) { s.insert(nums[i]); }
	<B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = k; i &lt; nums.size(); i++) {
		ret.push_back(*s.rbegin());
		s.erase(s.find(nums[i - k]));
		s.insert(nums[i]);
	}
	ret.push_back(*s.rbegin());
	<B><FONT COLOR="#A020F0">return</FONT></B> ret;
}

<I><FONT COLOR="#B22222">// In general, it is not required for the subarray to have constant size as long as
</FONT></I><I><FONT COLOR="#B22222">// both the left and right endpoints of the subarray only move to the right. 
</FONT></I><I><FONT COLOR="#B22222">// Find the longest contiguous subarray such that every element in the subarray is unique
</FONT></I><I><FONT COLOR="#B22222">// At each step, left pointer move to the right one step and right pointer move also to
</FONT></I><I><FONT COLOR="#B22222">// the right until it finds a duplicate. The current positions of left and right pointer
</FONT></I><I><FONT COLOR="#B22222">// indicate the longest subarray start at left
</FONT></I><B><FONT COLOR="#228B22">int</FONT></B> n;
set&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; s;

<B><FONT COLOR="#0000FF">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; n; i++) {
	<B><FONT COLOR="#A020F0">while</FONT></B> (r &lt; n - 1 &amp;&amp; !s.count(a[r + 1])) s.insert(a[++r]);
	ckmax(ans, r - i + 1);
	s.erase(a[i]);
}</PRE>
<HR>
<A NAME="file12">
<H1>code/graph/dijkstra.cc 12/70</H1>
[<A HREF="#top">top</A>][<A HREF="#file11">prev</A>][<A HREF="#file13">next</A>]
<PRE>
<I><FONT COLOR="#B22222">/**
 * Description: Dijkstra algorithm for finding SSSP
 * Time: O(Mlog N) 
 */</FONT></I>

<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">dijkstra</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> n, <B><FONT COLOR="#228B22">int</FONT></B> s, vector&lt;vector&lt;Edge&gt;&gt; &amp;E, vector&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B>&gt; &amp;D, vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; &amp;trace) {
    D.resize(n, INF);
    trace.resize(n, -1);
    vector&lt;<B><FONT COLOR="#228B22">bool</FONT></B>&gt; P(n, 0);

    D[s] = 0;
    priority_queue&lt;pi, vector&lt;pi&gt;, greater&lt;pi&gt;&gt; pq;
    pq.push({0, s});
    <B><FONT COLOR="#A020F0">while</FONT></B> (!pq.empty()) {
        <B><FONT COLOR="#228B22">int</FONT></B> u = pq.top().second;
        <B><FONT COLOR="#228B22">int</FONT></B> du = pq.top().first;
        pq.pop();
        <B><FONT COLOR="#A020F0">if</FONT></B> (du != D[u]) <B><FONT COLOR="#A020F0">continue</FONT></B>; <I><FONT COLOR="#B22222">// node is already processed or equivalently processed[u] = true
</FONT></I>        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">auto</FONT></B> e : E[u]) {
            <B><FONT COLOR="#228B22">int</FONT></B> v = e.v;
            <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> w = e.w;

            <B><FONT COLOR="#A020F0">if</FONT></B> (D[v] &gt; D[u] + w) {
                D[v] = D[u] + w;
                pq.push({v, D[v]});
                trace[v] = u;
            }
        }
    }
}

<I><FONT COLOR="#B22222">/*
Trick: To find all shortest paths of all nodes to a node A. Simply reverse 
the orginal graph and then run dijkstra from node A. Useful when finding shortest path
given the condition that an edge is fixed. 
*/</FONT></I></PRE>
<HR>
<A NAME="file13">
<H1>code/graph/bellmanford-ml.cc 13/70</H1>
[<A HREF="#top">top</A>][<A HREF="#file12">prev</A>][<A HREF="#file14">next</A>]
<PRE>
<I><FONT COLOR="#B22222">/**
 * Description: Bellman-Frod
 * Time: O(MN)
 */</FONT></I>

<B><FONT COLOR="#228B22">struct</FONT></B> Edge {
    <B><FONT COLOR="#228B22">int</FONT></B> u, v, w;
    Edge(<B><FONT COLOR="#228B22">int</FONT></B> u = 0, <B><FONT COLOR="#228B22">int</FONT></B> v = 0, <B><FONT COLOR="#228B22">int</FONT></B> w = 0) {
        <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;u = u;
        <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;v = v;
        <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;w = w;
    }
};

vi <B><FONT COLOR="#0000FF">d</FONT></B>(maxn, INF);
vi <B><FONT COLOR="#0000FF">path</FONT></B>(maxn, -1);
vector&lt;Edge&gt; g;
<B><FONT COLOR="#228B22">int</FONT></B> n, m;

<B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">BellmanFord</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> s) {
    <B><FONT COLOR="#228B22">int</FONT></B> u, v, w;
    d[s] = 0;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 1; i &lt;= n - 1; i++) {
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 0; j &lt; m; j++) {
            u = g[j].u;
            v = g[j].v;
            w = g[j].w;
            <B><FONT COLOR="#A020F0">if</FONT></B> (d[u] != INF &amp;&amp; d[u] + w &lt; d[v]) {
                d[v] = d[u] + w;
                path[v] = u;
            }
        }
    }

    <I><FONT COLOR="#B22222">// check if graph contains a negative cycle
</FONT></I>    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; m; i++) {
        u = g[i].u; v = g[i].v; w = g[i].w;
        <B><FONT COLOR="#A020F0">if</FONT></B> (d[u] != INF &amp;&amp; d[u] + w &lt; d[v]) {
            <B><FONT COLOR="#A020F0">return</FONT></B> false;
        }
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> true;
}

vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; trace_path(<B><FONT COLOR="#228B22">int</FONT></B> s, <B><FONT COLOR="#228B22">int</FONT></B> t) {
    <B><FONT COLOR="#A020F0">if</FONT></B> (t != s &amp;&amp; path[t] == -1) <B><FONT COLOR="#A020F0">return</FONT></B> vi(0);

    vi res;
    <B><FONT COLOR="#A020F0">while</FONT></B> (t != -1) {
        res.push_back(t);
        t = path[t];
    }
    reverse(res.begin(), res.end());
    <B><FONT COLOR="#A020F0">return</FONT></B> res;
}

<B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">findNegativeCycle</FONT></B>(vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; &amp;negCycle) {
    <I><FONT COLOR="#B22222">// after running Bellman-ford n - 1 times
</FONT></I>    <B><FONT COLOR="#228B22">int</FONT></B> negStart = -1;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">auto</FONT></B> E: g) {
        <B><FONT COLOR="#228B22">int</FONT></B> u = E.u;
        <B><FONT COLOR="#228B22">int</FONT></B> v = E.v;
        <B><FONT COLOR="#228B22">int</FONT></B> w = E.w;
        <B><FONT COLOR="#A020F0">if</FONT></B> (d[u] != INF &amp;&amp; d[v] &gt; d[u] + w) {
            d[v] = -INF; 
            path[v] = u;
            negStart = v;
        }
    }

    <B><FONT COLOR="#A020F0">if</FONT></B> (negStart == -1) <B><FONT COLOR="#A020F0">return</FONT></B> false; <I><FONT COLOR="#B22222">// no negative cycle
</FONT></I>
    <B><FONT COLOR="#228B22">int</FONT></B> u = negStart;
    <I><FONT COLOR="#B22222">// To get the vertices that are guaranteed to lie in a negative cycle
</FONT></I>    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; n; i++) {
        u = path[u];
    }

    negCycle = vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt;(1, u);
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> v = path[u]; v != u; v = path[u]) {
        negCycle.push_back(v); <I><FONT COLOR="#B22222">// truy vet mot dong
</FONT></I>    }
    reverse(negCycle.begin(), negCycle.end());
    
    <B><FONT COLOR="#A020F0">return</FONT></B> true;
}

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {
    cin &gt;&gt; n &gt;&gt; m;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; m; i++) {
        <B><FONT COLOR="#228B22">int</FONT></B> u, v, w;
        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;
        g.push_back(Edge(u, v, w));
    }

    <B><FONT COLOR="#228B22">int</FONT></B> s = 0;
    <B><FONT COLOR="#228B22">bool</FONT></B> res = BellmanFord(s);

    <B><FONT COLOR="#A020F0">if</FONT></B> (!res) {
        <I><FONT COLOR="#B22222">// if there is a negative cycle, identify all nodes that does not exist shortest path
</FONT></I>        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; n; i++) {
            <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">auto</FONT></B> E : g) {
                <B><FONT COLOR="#228B22">int</FONT></B> u = E.u; 
                <B><FONT COLOR="#228B22">int</FONT></B> v = E.v; 
                <B><FONT COLOR="#228B22">int</FONT></B> w = E.w; 
                <B><FONT COLOR="#A020F0">if</FONT></B> (d[u] != INF &amp;&amp; d[v] &gt; d[u] + w) {
                    d[v] = -INF; path[v] = u;
                }
            }
        }
    }

    <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}</PRE>
<HR>
<A NAME="file14">
<H1>code/graph/floydwarshall.cc 14/70</H1>
[<A HREF="#top">top</A>][<A HREF="#file13">prev</A>][<A HREF="#file15">next</A>]
<PRE>
<I><FONT COLOR="#B22222">/**
 * Description: Floyd warshall
 * Time: O(N^3)
 */</FONT></I>

<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">init_trace</FONT></B>(vector&lt;vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt;&gt; &amp;trace) {
    <B><FONT COLOR="#228B22">int</FONT></B> n = trace.size();
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> u = 0; u &lt; n; u++) {
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> v = 0; v &lt; n; v++) {
            trace[u][v] = u;
        }
    }
}

<B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">floydWarshall</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> n, vector&lt;vector&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B>&gt;&gt; &amp;w, vector&lt;vector&lt;<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B>&gt;&gt; &amp;D, vector&lt;vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt;&gt; &amp;trace) {
    D = w; <I><FONT COLOR="#B22222">// if d[i][i] = 0, d[i][j] = INF if no edge
</FONT></I>    init_trace(trace); <I><FONT COLOR="#B22222">// neu can do duong di
</FONT></I>    
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> k = 0; k &lt; n; ++k) {
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; n; ++i) {
            <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 0; j &lt; n; ++j) {
                <I><FONT COLOR="#B22222">// if the graph has negative weight edges, it is better to write the Floyd-Warshall algorithm in the following way, so that it does not perform transitions using paths that don't exist.
</FONT></I>                <B><FONT COLOR="#A020F0">if</FONT></B> (D[i][k] &lt; INF &amp;&amp; D[k][j] &lt; INF) {
                    D[i][j] = min(D[i][j], D[i][k] + D[k][j]); 
                    trace[i][j] = trace[k][j];

                    <I><FONT COLOR="#B22222">// make sure that D[i][j] wont be overflow when graph contains negative cycles
</FONT></I>                    D[i][j] = max(D[i][j], -INF);
                }
            }
        }
    }

    <I><FONT COLOR="#B22222">// check if graph contain negative cycle
</FONT></I>    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; n; i++) {
        <B><FONT COLOR="#A020F0">if</FONT></B> (D[i][i] &lt; 0) <B><FONT COLOR="#A020F0">return</FONT></B> false;
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> true;
}

vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; trace_path(vector&lt;vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt;&gt; &amp;trace, <B><FONT COLOR="#228B22">int</FONT></B> u, <B><FONT COLOR="#228B22">int</FONT></B> v) {
    vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; path;
    <B><FONT COLOR="#A020F0">while</FONT></B> (v != u) { <I><FONT COLOR="#B22222">// truy vet nguoc tu v ve u
</FONT></I>        path.push_back(v);
        v = trace[u][v];
    }
    path.push_back(u);
    
    reverse(path.begin(), path.end()); <I><FONT COLOR="#B22222">// can reverse vi duong di tu v nguoc ve u
</FONT></I>    
    <B><FONT COLOR="#A020F0">return</FONT></B> path;
}</PRE>
<HR>
<A NAME="file15">
<H1>code/graph/bfs.cc 15/70</H1>
[<A HREF="#top">top</A>][<A HREF="#file14">prev</A>][<A HREF="#file16">next</A>]
<PRE>
<I><FONT COLOR="#B22222">/**
 * Description: BFS
 * Time: O(V + E)
 */</FONT></I>

<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">BFS</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> s) {
    queue&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; q;
    visited[s] = true;
    q.push(s);
    
    <B><FONT COLOR="#A020F0">while</FONT></B> (!q.empty()){
        <B><FONT COLOR="#228B22">int</FONT></B> u = q.front(); 
        q.pop();
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">auto</FONT></B> v : g[u]){
            <B><FONT COLOR="#A020F0">if</FONT></B> (!visited[v]){
                visited[v] = true;
                d[v] = d[u] + 1;
                path[v] = u;
                q.push(v);
            }
        }
    }
}

<I><FONT COLOR="#B22222">// Tracing 
</FONT></I><B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">printPath</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> u) {
    <B><FONT COLOR="#A020F0">if</FONT></B> (!visited[u]) cout &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;No path!&quot;</FONT></B>;
    <B><FONT COLOR="#A020F0">else</FONT></B> {
        vi path;
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> v = u; v != -1; v = path[v]){
            path.push_back(v);
        }
        reverse(path.begin(), path.end());
        cout &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;Path: &quot;</FONT></B>;
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">auto</FONT></B> v: path) cout &lt;&lt; v &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>;
    }
}</PRE>
<HR>
<A NAME="file16">
<H1>code/graph/bfs01.cc 16/70</H1>
[<A HREF="#top">top</A>][<A HREF="#file15">prev</A>][<A HREF="#file17">next</A>]
<PRE>
<I><FONT COLOR="#B22222">/**
 * Description: 0-1 BFS, find shortest path in 0-1 weighted graph.
 * Time: better than Dijkstra
 */</FONT></I>

<I><FONT COLOR="#B22222">// 0-1 BFS could be use to find the minimum of edges that is needed to 
</FONT></I><I><FONT COLOR="#B22222">// be reversed in direction to make the path 1-&gt;N possible
</FONT></I>
<B><FONT COLOR="#228B22">int</FONT></B> n, m;
<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> inf = 1e9;
<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> maxn = 1e5 + 7;
vector&lt;pi&gt; g[maxn];
<B><FONT COLOR="#228B22">int</FONT></B> d[maxn];

<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">sssp</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> s) {
    fill_n(d, n + 1, inf);
    deque&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; q;
    q.push_back(s);
    d[s] = 0;
    <B><FONT COLOR="#A020F0">while</FONT></B> (!q.empty()) {
        <B><FONT COLOR="#228B22">int</FONT></B> u = q.front();
        q.pop_front();

        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">auto</FONT></B> e: g[u]) {
            <B><FONT COLOR="#228B22">int</FONT></B> v = e.second;
            <B><FONT COLOR="#228B22">int</FONT></B> uv = e.first;
            <B><FONT COLOR="#A020F0">if</FONT></B> (d[v] &gt; d[u] + uv) {
                d[v] = d[u] + uv;
                <B><FONT COLOR="#A020F0">if</FONT></B> (uv == 1) {
                    q.push_back(v);
                }
                <B><FONT COLOR="#A020F0">else</FONT></B> {
                    q.push_front(v);
                }
            }
        }
    }
}
</PRE>
<HR>
<A NAME="file17">
<H1>code/graph/kruskal.cc 17/70</H1>
[<A HREF="#top">top</A>][<A HREF="#file16">prev</A>][<A HREF="#file18">next</A>]
<PRE>
<I><FONT COLOR="#B22222">/**
 * Description: Kruskal Algo
 * Time: if the graph is densed, use Prim for better performance
 */</FONT></I>

<B><FONT COLOR="#228B22">struct</FONT></B> DSU {
    vi lab;
    DSU(<B><FONT COLOR="#228B22">int</FONT></B> n) { lab = vi(n, -1); }

    <B><FONT COLOR="#228B22">int</FONT></B> get(<B><FONT COLOR="#228B22">int</FONT></B> x) { <B><FONT COLOR="#A020F0">return</FONT></B> lab[x] &lt; 0 ? x : lab[x] = get(lab[x]); }

    <B><FONT COLOR="#228B22">bool</FONT></B> same_set(<B><FONT COLOR="#228B22">int</FONT></B> a, <B><FONT COLOR="#228B22">int</FONT></B> b) { <B><FONT COLOR="#A020F0">return</FONT></B> get(a) == get(b); }

    <B><FONT COLOR="#228B22">bool</FONT></B> unite(<B><FONT COLOR="#228B22">int</FONT></B> x, <B><FONT COLOR="#228B22">int</FONT></B> y) {  
		x = get(x), y = get(y);
		<B><FONT COLOR="#A020F0">if</FONT></B> (x == y) <B><FONT COLOR="#A020F0">return</FONT></B> false;
		<B><FONT COLOR="#A020F0">if</FONT></B> (lab[x] &gt; lab[y]) swap(x, y);
		lab[x] += lab[y];
		lab[y] = x;
		<B><FONT COLOR="#A020F0">return</FONT></B> true;
	}
};

ll <B><FONT COLOR="#0000FF">kruskal</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> n, vector&lt;pair&lt;ll, pi&gt;&gt; Edges) {
    DSU d(n); 
    ll res = 0; <B><FONT COLOR="#228B22">int</FONT></B> taken = 0;

    sort(Edges.begin(), Edges.end());

    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">auto</FONT></B> edge: Edges) {
        <B><FONT COLOR="#228B22">int</FONT></B> u = edge.second.first;
        <B><FONT COLOR="#228B22">int</FONT></B> v = edge.second.second;
        <B><FONT COLOR="#A020F0">if</FONT></B> (d.unite(u, v)) {
            res += edge.first;
            taken++;
        }
        <B><FONT COLOR="#A020F0">if</FONT></B> (taken == n - 1) <B><FONT COLOR="#A020F0">break</FONT></B>;
    }
    <B><FONT COLOR="#A020F0">if</FONT></B> (taken != n - 1) <B><FONT COLOR="#A020F0">return</FONT></B> -1;
    <B><FONT COLOR="#A020F0">return</FONT></B> res;
}</PRE>
<HR>
<A NAME="file18">
<H1>code/graph/prim.cc 18/70</H1>
[<A HREF="#top">top</A>][<A HREF="#file17">prev</A>][<A HREF="#file19">next</A>]
<PRE>
<I><FONT COLOR="#B22222">/**
 * Description: Prim Algo
 * Time: O(ElogV)
 * Status: 
 */</FONT></I>

<B><FONT COLOR="#228B22">typedef</FONT></B> pair&lt;<B><FONT COLOR="#228B22">int</FONT></B>, <B><FONT COLOR="#228B22">int</FONT></B>&gt; ii;
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; vi;
<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;ii&gt; vii;

vector&lt;vii&gt; AL;                                  <I><FONT COLOR="#B22222">// the graph stored in AL
</FONT></I>vi taken;                                        <I><FONT COLOR="#B22222">// to avoid cycle
</FONT></I>priority_queue&lt;ii&gt; pq;                           <I><FONT COLOR="#B22222">// to select shorter edges
</FONT></I><I><FONT COLOR="#B22222">// C++ STL priority_queue is a max heap, we use -ve sign to reverse order
</FONT></I>
<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">process</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> u) { <I><FONT COLOR="#B22222">// set u as taken and enqueue neighbors of u
</FONT></I>  taken[u] = 1;
  <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">auto</FONT></B> &amp;[v, w] : AL[u])
    <B><FONT COLOR="#A020F0">if</FONT></B> (!taken[v])
      pq.push({-w, -v});                         <I><FONT COLOR="#B22222">// sort by non-dec weight
</FONT></I>}                                                <I><FONT COLOR="#B22222">// then by inc id
</FONT></I>
<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {
    <B><FONT COLOR="#228B22">int</FONT></B> V, E; scanf(<B><FONT COLOR="#BC8F8F">&quot;%d %d&quot;</FONT></B>, &amp;V, &amp;E);
    AL.assign(V, vii());
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; E; ++i) {
        <B><FONT COLOR="#228B22">int</FONT></B> u, v, w; scanf(<B><FONT COLOR="#BC8F8F">&quot;%d %d %d&quot;</FONT></B>, &amp;u, &amp;v, &amp;w);  <I><FONT COLOR="#B22222">// read as (u, v, w)
</FONT></I>        AL[u].emplace_back(v, w);
        AL[v].emplace_back(u, w);
    }
    taken.assign(V, 0);                            <I><FONT COLOR="#B22222">// no vertex is taken
</FONT></I>    process(0);                                    <I><FONT COLOR="#B22222">// take+process vertex 0
</FONT></I>    <B><FONT COLOR="#228B22">int</FONT></B> mst_cost = 0, num_taken = 0;               <I><FONT COLOR="#B22222">// no edge has been taken
</FONT></I>    <B><FONT COLOR="#A020F0">while</FONT></B> (!pq.empty()) {                          <I><FONT COLOR="#B22222">// up to O(E)
</FONT></I>        <B><FONT COLOR="#228B22">auto</FONT></B> [w, u] = pq.top(); pq.pop();            <I><FONT COLOR="#B22222">// C++17 style
</FONT></I>        w = -w; u = -u;                              <I><FONT COLOR="#B22222">// negate to reverse order
</FONT></I>        <B><FONT COLOR="#A020F0">if</FONT></B> (taken[u]) <B><FONT COLOR="#A020F0">continue</FONT></B>;                      <I><FONT COLOR="#B22222">// already taken, skipped
</FONT></I>        mst_cost += w;                               <I><FONT COLOR="#B22222">// add w of this edge
</FONT></I>        process(u);                                  <I><FONT COLOR="#B22222">// take+process vertex u
</FONT></I>        ++num_taken;                                 <I><FONT COLOR="#B22222">// 1 more edge is taken
</FONT></I>        <B><FONT COLOR="#A020F0">if</FONT></B> (num_taken == V-1) <B><FONT COLOR="#A020F0">break</FONT></B>;                 <I><FONT COLOR="#B22222">// optimization
</FONT></I>    }
    printf(<B><FONT COLOR="#BC8F8F">&quot;MST cost = %d (Prim's)\n&quot;</FONT></B>, mst_cost);

}
</PRE>
<HR>
<A NAME="file19">
<H1>code/graph/variants.txt 19/70</H1>
[<A HREF="#top">top</A>][<A HREF="#file18">prev</A>][<A HREF="#file20">next</A>]
<PRE>
/**
 * Description: Some variants of MST problems
 */

Minimum Spanning Subgraph of MST problem. Some edges in the given graph have already been 
fixed and must be taken as part of the solution. For Kruskal's algorithm, we first take 
into account all the fixed edges and their costs. Then, we continue running Kruskal's 
algorithm on the remaining free edges until we have a spanning subgraph (or spanning tree). 
For Prim's algorithm, we give higher priorities to these fixed edges so that we will always 
take them and their costs.


Second-Best Spanning Tree of MST problem, We can see that the second best ST is actually the
MST with just two edges difference. One edge is taken out from the MST and another chord edge 
is added into the MST. Next, for each edge in the MST (there are at most V-1 edges in the MST), 
temporarily flag it so that it cannot be chosen, then try to find the MST again in O(E) but now 
excluding that flagged edge. Note that we do not have to re-sort the edges at this point. The 
best spanning tree found after this process is the second best ST. 
</PRE>
<HR>
<A NAME="file20">
<H1>code/graph/floodfill.cc 20/70</H1>
[<A HREF="#top">top</A>][<A HREF="#file19">prev</A>][<A HREF="#file21">next</A>]
<PRE>
<I><FONT COLOR="#B22222">/**
 * Description: FloodFill
 */</FONT></I>

<I><FONT COLOR="#B22222">// const int dx[8]{1,0,-1,0,-1,1,-1,1}, dy[8]{0,1,0,-1,-1,1,1,-1}; 
</FONT></I><I><FONT COLOR="#B22222">// const int dx[4]{1,0,-1,0}, dy[8]{0,1,0,-1}; 
</FONT></I><B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">isValid</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> r, <B><FONT COLOR="#228B22">int</FONT></B> c){
    <B><FONT COLOR="#A020F0">return</FONT></B> r &gt;= 0 &amp;&amp; r &lt; n &amp;&amp; c &gt;= 0 &amp;&amp; c &lt; m;
}

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">bfs</FONT></B>(pi c){
    <B><FONT COLOR="#228B22">int</FONT></B> size = 1;
    visited[c.f][c.s] = true;
    queue&lt;pi&gt; q;
    q.push(c);
    <B><FONT COLOR="#A020F0">while</FONT></B> (!q.empty()) {
        <B><FONT COLOR="#228B22">int</FONT></B> x = q.front().first;
        <B><FONT COLOR="#228B22">int</FONT></B> y = q.front().second;
        q.pop();

        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; 4; i++){
            <B><FONT COLOR="#228B22">int</FONT></B> u = x + dx[i];
            <B><FONT COLOR="#228B22">int</FONT></B> v = y + dy[i];
            <B><FONT COLOR="#A020F0">if</FONT></B> (isValid(u, v) &amp;&amp; a[u][v] == 1 &amp;&amp; !visited[u][v]){
                q.push({u, v});
                size++;
                visited[u][v] = true;
            }
        }
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> size;
}
</PRE>
<HR>
<A NAME="file21">
<H1>code/graph/bipartiteness.cc 21/70</H1>
[<A HREF="#top">top</A>][<A HREF="#file20">prev</A>][<A HREF="#file22">next</A>]
<PRE>
<I><FONT COLOR="#B22222">/**
 * Description: Bipartiteness 
 * Time: O(V + E)
 */</FONT></I>

<B><FONT COLOR="#228B22">int</FONT></B> n, l;
<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> maxn = 210;
vector&lt;vi&gt; g(maxn);
<B><FONT COLOR="#228B22">int</FONT></B> color[maxn];

<I><FONT COLOR="#B22222">// A Bipartite Graph has no odd-length cycle
</FONT></I>
<B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">checkBipartite</FONT></B>() {
    fill_n(color, n + 1, -1);

    queue&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; q;
    q.push(0);
    color[0] = 0;
    <B><FONT COLOR="#A020F0">while</FONT></B> (!q.empty()) {
        <B><FONT COLOR="#228B22">int</FONT></B> u = q.front();
        q.pop();
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">auto</FONT></B> v : g[u]) {
            <B><FONT COLOR="#A020F0">if</FONT></B> (color[v] == color[u]) <B><FONT COLOR="#A020F0">return</FONT></B> false;
            <B><FONT COLOR="#A020F0">if</FONT></B> (color[v] == -1) {
                color[v] = !color[u];
                q.push(v);
            }
        }
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> true;
}</PRE>
<HR>
<A NAME="file22">
<H1>code/graph/shortestCycle.cc 22/70</H1>
[<A HREF="#top">top</A>][<A HREF="#file21">prev</A>][<A HREF="#file23">next</A>]
<PRE>
<I><FONT COLOR="#B22222">/**
 * Description: Find shortest cycle starting from a source vertex
 */</FONT></I>


<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">bfs</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> s) {
    fill_n(d, n + 1, 0);
    fill_n(visit, n + 1, false);

    queue &lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; q;
    q.push(s);
    visit[s] = true;
    <B><FONT COLOR="#A020F0">while</FONT></B> (!q.empty()) {
        <B><FONT COLOR="#228B22">int</FONT></B> u = q.front();
        q.pop();
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">auto</FONT></B> v : g[u]) {
            
            <I><FONT COLOR="#B22222">// If get back to source, return cycle length and end BFS
</FONT></I>            <B><FONT COLOR="#A020F0">if</FONT></B> (v == s) <B><FONT COLOR="#A020F0">return</FONT></B> d[u] + 1;
            
            <B><FONT COLOR="#A020F0">if</FONT></B> (!visit[v]) {
                d[v] = d[u] + 1;
                visit[v] = true;
                q.push(v);
            }
        }
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}</PRE>
<HR>
<A NAME="file23">
<H1>code/graph/kahn.cc 23/70</H1>
[<A HREF="#top">top</A>][<A HREF="#file22">prev</A>][<A HREF="#file24">next</A>]
<PRE>
<I><FONT COLOR="#B22222">/**
 * Description: Kahn Algorithm for Topo sort
 */</FONT></I>

vi <B><FONT COLOR="#0000FF">toposort</FONT></B>() {
    vi order;
    queue&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; q;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 1; i &lt;= n; i++) {
        <B><FONT COLOR="#A020F0">if</FONT></B> (indeg[i] == 0) q.push(i);
    }
    <B><FONT COLOR="#A020F0">while</FONT></B> (!q.empty()) {
        <B><FONT COLOR="#228B22">int</FONT></B> cur = q.front();
        q.pop();
        order.push_back(cur); 
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">auto</FONT></B> v : g[cur]) {
            indeg[v]--; 
            <B><FONT COLOR="#A020F0">if</FONT></B> (indeg[v] == 0) q.push(v);   
        }
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> order;
}

<I><FONT COLOR="#B22222">// if there isn't a valid topological sorting
</FONT></I><B><FONT COLOR="#0000FF">if</FONT></B> (order.size() != n) {
    
}

<I><FONT COLOR="#B22222">/*
We can also use Kahn's algorithm to extract the lexicographically minimum 
topological sort by breaking ties lexographically. Simply replace the queue 
with a priority_queue to implement this extension.
*/</FONT></I>
</PRE>
<HR>
<A NAME="file24">
<H1>code/graph/dfsTopo.cc 24/70</H1>
[<A HREF="#top">top</A>][<A HREF="#file23">prev</A>][<A HREF="#file25">next</A>]
<PRE>
<I><FONT COLOR="#B22222">/**
 * Description: using DFS to find one valid Topo Sort of a give DAG
 */</FONT></I>

<I><FONT COLOR="#B22222">/*
Every DAG has at least one (a Singly Linked List-like DAG), 
possibly more than one topological sorts, and up to n! topological sorts 
(a DAG with n vertices and 0 edge). There is no possible topological ordering of a non DAG.
*/</FONT></I>
<B><FONT COLOR="#228B22">int</FONT></B> n, m;
<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> maxn = 1e5 + 7;
vector&lt;vi&gt; g(maxn);
vector&lt;<B><FONT COLOR="#228B22">bool</FONT></B>&gt; visited(maxn, false);
vi res;

<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">dfs</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> s) {
    visited[s] = true;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">auto</FONT></B> u : g[s]) { 
        <B><FONT COLOR="#A020F0">if</FONT></B> (!visited[u]) dfs(u); 
    }
    res.PB(s);
}

<B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">toposort</FONT></B>() {
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 1; i &lt;= n; i++) {
        <B><FONT COLOR="#A020F0">if</FONT></B> (!visited[i]) dfs(i);
    }
    reverse(res.begin(), res.end());

    <I><FONT COLOR="#B22222">// check if the graph is actually a DAG
</FONT></I>    vi ind(n + 3);
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; n; i++) ind[res[i]] = i + 1;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 1; i &lt;= n; i++) {
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">auto</FONT></B> u : g[i]) {
            <B><FONT COLOR="#A020F0">if</FONT></B> (ind[u] &lt; ind[i]) <B><FONT COLOR="#A020F0">return</FONT></B> false;
        }
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> true;
}

<I><FONT COLOR="#B22222">// return true if graph is a DAG, valid topo order is stored in res
</FONT></I></PRE>
<HR>
<A NAME="file25">
<H1>code/graph/dpDag.cc 25/70</H1>
[<A HREF="#top">top</A>][<A HREF="#file24">prev</A>][<A HREF="#file26">next</A>]
<PRE>
<I><FONT COLOR="#B22222">/**
 * Description: DP on DAG
 */</FONT></I>

<I><FONT COLOR="#B22222">// Extending Dijkstra algorithm
</FONT></I><I><FONT COLOR="#B22222">/*
A by product of Dijkstra algorithm is a directed, acyclic graph that indicates
for each node of the original graph the possible ways to reach the node using a
shortest path from the starting node. Dynamic programming can be applied to
that graph. For example: calculate the number of shortest paths from node 1
to node 5 using dynamic programming
*/</FONT></I>

<I><FONT COLOR="#B22222">/*
 If we process the states in topological order, it is guaranteed that dp[u]
 will already have been computed before computing dp[v]
*/</FONT></I>

<I><FONT COLOR="#B22222">// Example: ordering of node to be processed
</FONT></I>
vi order = toposort();
dp[1] = 1;
<B><FONT COLOR="#0000FF">for</FONT></B> (<B><FONT COLOR="#228B22">auto</FONT></B> city : order) {
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">auto</FONT></B> prev : rev_g[city]) {
        ckmax(dp[city], dp[prev] + 1);
    }
}
cout &lt;&lt; dp[n] &lt;&lt; endl;
</PRE>
<HR>
<A NAME="file26">
<H1>code/graph/cycleCheck.cc 26/70</H1>
[<A HREF="#top">top</A>][<A HREF="#file25">prev</A>][<A HREF="#file27">next</A>]
<PRE>
<I><FONT COLOR="#B22222">/**
 * Description: Cycle Check
 */</FONT></I>


<I><FONT COLOR="#B22222">/*
We will run a series of DFS in the graph. Initially all vertices are colored white (0). 
From each unvisited (white) vertex, start the DFS, mark it gray (1) while entering 
and mark it black (2) on exit. If DFS moves to a gray vertex, then we have found a cycle 
(if the graph is undirected, the edge to parent is not considered). 
The cycle itself can be reconstructed using parent array.
*/</FONT></I>

<I><FONT COLOR="#B22222">// For directed graph
</FONT></I><B><FONT COLOR="#228B22">int</FONT></B> n;
vector&lt;vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt;&gt; adj;
vector&lt;<B><FONT COLOR="#228B22">char</FONT></B>&gt; color;
vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; parent;
<B><FONT COLOR="#228B22">int</FONT></B> cycle_start, cycle_end;

<B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">dfs</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> v) {
    color[v] = 1;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> u : adj[v]) {
        <B><FONT COLOR="#A020F0">if</FONT></B> (color[u] == 0) {
            parent[u] = v;
            <B><FONT COLOR="#A020F0">if</FONT></B> (dfs(u))
                <B><FONT COLOR="#A020F0">return</FONT></B> true;
        } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (color[u] == 1) {
            cycle_end = v;
            cycle_start = u;
            <B><FONT COLOR="#A020F0">return</FONT></B> true;
        }
    }
    color[v] = 2;
    <B><FONT COLOR="#A020F0">return</FONT></B> false;
}

<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">find_cycle</FONT></B>() {
    color.assign(n, 0);
    parent.assign(n, -1);
    cycle_start = -1;

    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> v = 0; v &lt; n; v++) {
        <B><FONT COLOR="#A020F0">if</FONT></B> (color[v] == 0 &amp;&amp; dfs(v))
            <B><FONT COLOR="#A020F0">break</FONT></B>;
    }

    <B><FONT COLOR="#A020F0">if</FONT></B> (cycle_start == -1) {
        cout &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;Acyclic&quot;</FONT></B> &lt;&lt; endl;
    } <B><FONT COLOR="#A020F0">else</FONT></B> {
        vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; cycle;
        cycle.push_back(cycle_start);
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> v = cycle_end; v != cycle_start; v = parent[v])
            cycle.push_back(v);
        cycle.push_back(cycle_start);
        reverse(cycle.begin(), cycle.end());

        cout &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;Cycle found: &quot;</FONT></B>;
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> v : cycle)
            cout &lt;&lt; v &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>;
        cout &lt;&lt; endl;
    }
}

<I><FONT COLOR="#B22222">/*
In undirected graph, another way is to simply calculate the number of nodes and edges in every 
component. If a component contains c nodes and no cycle, it must contain exactly c-1 edges 
(so it has to be a tree). If there are c or more edges, the component surely contains a cycle.
*/</FONT></I>

<I><FONT COLOR="#B22222">/*
Here is an implementation for undirected graph. Note that in the undirected version, if a vertex 
v gets colored black, it will never be visited again by the DFS. This is because we already
explored all connected edges of v when we first visited it. The connected component containing v 
(after removing the edge between v and its parent) must be a tree, if the DFS has completed 
processing v without finding a cycle. So we don't even need to distinguish between gray and black 
states. Thus we can turn the char vector color into a boolean vector visited.
*/</FONT></I>

<I><FONT COLOR="#B22222">// undirected graph
</FONT></I><B><FONT COLOR="#228B22">int</FONT></B> n;
vector&lt;vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt;&gt; adj;
vector&lt;<B><FONT COLOR="#228B22">bool</FONT></B>&gt; visited;
vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; parent;
<B><FONT COLOR="#228B22">int</FONT></B> cycle_start, cycle_end;

<B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">dfs</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> v, <B><FONT COLOR="#228B22">int</FONT></B> par) { <I><FONT COLOR="#B22222">// passing vertex and its parent vertex
</FONT></I>    visited[v] = true;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> u : adj[v]) {
        <B><FONT COLOR="#A020F0">if</FONT></B>(u == par) <B><FONT COLOR="#A020F0">continue</FONT></B>; <I><FONT COLOR="#B22222">// skipping edge to parent vertex
</FONT></I>        <B><FONT COLOR="#A020F0">if</FONT></B> (visited[u]) {
            cycle_end = v;
            cycle_start = u;
            <B><FONT COLOR="#A020F0">return</FONT></B> true;
        }
        parent[u] = v;
        <B><FONT COLOR="#A020F0">if</FONT></B> (dfs(u, parent[u]))
            <B><FONT COLOR="#A020F0">return</FONT></B> true;
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> false;
}

<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">find_cycle</FONT></B>() {
    visited.assign(n, false);
    parent.assign(n, -1);
    cycle_start = -1;

    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> v = 0; v &lt; n; v++) {
        <B><FONT COLOR="#A020F0">if</FONT></B> (!visited[v] &amp;&amp; dfs(v, parent[v]))
            <B><FONT COLOR="#A020F0">break</FONT></B>;
    }

    <B><FONT COLOR="#A020F0">if</FONT></B> (cycle_start == -1) {
        cout &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;Acyclic&quot;</FONT></B> &lt;&lt; endl;
    } <B><FONT COLOR="#A020F0">else</FONT></B> {
        vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; cycle;
        cycle.push_back(cycle_start);
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> v = cycle_end; v != cycle_start; v = parent[v])
            cycle.push_back(v);
        cycle.push_back(cycle_start);

        cout &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;Cycle found: &quot;</FONT></B>;
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> v : cycle)
            cout &lt;&lt; v &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>;
        cout &lt;&lt; endl;
    }
}</PRE>
<HR>
<A NAME="file27">
<H1>code/tree/general.cc 27/70</H1>
[<A HREF="#top">top</A>][<A HREF="#file26">prev</A>][<A HREF="#file28">next</A>]
<PRE>
<I><FONT COLOR="#B22222">/**
 * Description: General about tree
 */</FONT></I>

<I><FONT COLOR="#B22222">/*
Tree traversal is easier to implement than a general graph, There are no cycles in the 
tree and it is not possible to reach a node from multiple directions.

A general way to approach many tree problems is to first root the tree arbitrarily.
After this, we can try to solve the problem separately for each subtree.

An important observation is that every path in a rooted tree has a highest
point: the highest node that belongs to the path.
*/</FONT></I>

<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">dfs</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> s, <B><FONT COLOR="#228B22">int</FONT></B> e) {
    res[s] = 1; <I><FONT COLOR="#B22222">// calculate some information during a tree traversal
</FONT></I>    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">auto</FONT></B> u : g[s]) {
        <B><FONT COLOR="#A020F0">if</FONT></B> (u == e) <B><FONT COLOR="#A020F0">continue</FONT></B>;
        dfs(u, s);
        res[s] += res[u];
    }
}

<B><FONT COLOR="#0000FF">dfs</FONT></B>(x, 0); <I><FONT COLOR="#B22222">// first node
</FONT></I></PRE>
<HR>
<A NAME="file28">
<H1>code/tree/treeDiameter.cc 28/70</H1>
[<A HREF="#top">top</A>][<A HREF="#file27">prev</A>][<A HREF="#file29">next</A>]
<PRE>
<I><FONT COLOR="#B22222">/**
 * Description: Tree Diameter
 */</FONT></I>

<I><FONT COLOR="#B22222">/*
Run a DFS from any node p. Let a be a node whose distance from node p is maximized. 
Run another DFS from node a. Let b be a node whose distance from node a is maximized. 
a -&gt; b is a diameter.

the height of each component with root in the left half of the diameter 
(i.e., dist(a,d)&lt;dist(d,b)) is at most the distance of the root of the component from 
the left end of the diameter. Same statement for the right half of the diameter

For each node i, let's find a node j such that dist(i,j) is maximum.
Claim: j = a or j = b always works.

Most of the times, spamming &quot;the farthest node from each node is one end of the diameter&quot; 
and &quot;the height of each component is smaller than the distance to the closest end of the diameter&quot; 
is enough to reduce the problem to something simpler. you may need to consider any path of the 
tree. There are two cases: the path intersects or doesn't intersect the diameter.
*/</FONT></I>



pi <B><FONT COLOR="#0000FF">dfs</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> cur, <B><FONT COLOR="#228B22">int</FONT></B> par) {
    pi res = {0, cur};
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">auto</FONT></B> u : g[cur]) {
        <B><FONT COLOR="#A020F0">if</FONT></B> (u == par) <B><FONT COLOR="#A020F0">continue</FONT></B>;
        pi tmp = dfs(u, cur);
        tmp.first++;
        ckmax(res, tmp);
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> res;
}

<B><FONT COLOR="#228B22">int</FONT></B> a = dfs(1, 0).second;
<B><FONT COLOR="#228B22">int</FONT></B> b = dfs(a, 0).first; </PRE>
<HR>
<A NAME="file29">
<H1>code/tree/lca.cc 29/70</H1>
[<A HREF="#top">top</A>][<A HREF="#file28">prev</A>][<A HREF="#file30">next</A>]
<PRE>
<I><FONT COLOR="#B22222">/**
 * Description: Different methods for finding LCA in a tree
 */</FONT></I>

<I><FONT COLOR="#B22222">// Method 1: Euler tour + RMQ (SegTree / Sparse Table). Node should be numbered from 0
</FONT></I><I><FONT COLOR="#B22222">// O(N) preprocessing, O(logN) queries: segtree
</FONT></I><I><FONT COLOR="#B22222">// O(NlogN) preprocessing, O(1) queries: Sparse Table (static data)
</FONT></I><B><FONT COLOR="#228B22">struct</FONT></B> LCA {
    vi height, euler, first, st;
    <B><FONT COLOR="#228B22">int</FONT></B> n;

    LCA(<B><FONT COLOR="#228B22">int</FONT></B> _n, <B><FONT COLOR="#228B22">int</FONT></B> root = 0) {
        n = _n;
        height.resize(n);
        first.resize(n);
        euler.reserve(2 * n);
        dfs(root, -1);
        <B><FONT COLOR="#228B22">int</FONT></B> m = sz(euler);
        st.resize(4 * m);
        build(1, 0, m - 1);
    }

    <I><FONT COLOR="#B22222">// build euler path
</FONT></I>    <B><FONT COLOR="#228B22">void</FONT></B> dfs(<B><FONT COLOR="#228B22">int</FONT></B> cur, <B><FONT COLOR="#228B22">int</FONT></B> par, <B><FONT COLOR="#228B22">int</FONT></B> h = 0) {
        height[cur] = h;
        first[cur] = sz(euler);
        euler.push_back(cur);
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">auto</FONT></B> next : g[cur]) {
            <B><FONT COLOR="#A020F0">if</FONT></B> (next == par) <B><FONT COLOR="#A020F0">continue</FONT></B>;
            dfs(next, cur, h + 1);
            euler.push_back(cur);
        }
    }

    <I><FONT COLOR="#B22222">// Segtree
</FONT></I>    <B><FONT COLOR="#228B22">void</FONT></B> build(<B><FONT COLOR="#228B22">int</FONT></B> id, <B><FONT COLOR="#228B22">int</FONT></B> l, <B><FONT COLOR="#228B22">int</FONT></B> r) { <I><FONT COLOR="#B22222">// O(n)
</FONT></I>        <B><FONT COLOR="#A020F0">if</FONT></B> (l == r) {
            st[id] = euler[l];
            <B><FONT COLOR="#A020F0">return</FONT></B>;
        }
        <B><FONT COLOR="#228B22">int</FONT></B> mid = (l + r) &gt;&gt; 1;
        build(2 * id, l, mid);
        build(2 * id + 1, mid + 1, r);
        <B><FONT COLOR="#228B22">int</FONT></B> lchild = st[2 * id], rchild = st[2 * id  + 1];
        st[id] = (height[lchild] &lt; height[rchild]) ? lchild : rchild;
    }

    <B><FONT COLOR="#228B22">int</FONT></B> get(<B><FONT COLOR="#228B22">int</FONT></B> id, <B><FONT COLOR="#228B22">int</FONT></B> l, <B><FONT COLOR="#228B22">int</FONT></B> r, <B><FONT COLOR="#228B22">int</FONT></B> u, <B><FONT COLOR="#228B22">int</FONT></B> v) { <I><FONT COLOR="#B22222">// O(log n)
</FONT></I>        <B><FONT COLOR="#A020F0">if</FONT></B> (l &gt;  v || r &lt;  u) <B><FONT COLOR="#A020F0">return</FONT></B> -inf;
        <B><FONT COLOR="#A020F0">if</FONT></B> (l &gt;= u &amp;&amp; r &lt;= v) <B><FONT COLOR="#A020F0">return</FONT></B> st[id];

        <B><FONT COLOR="#228B22">int</FONT></B> mid = (l + r) &gt;&gt; 1;
        <B><FONT COLOR="#228B22">int</FONT></B> get1 = get(2 * id, l, mid, u, v);
        <B><FONT COLOR="#228B22">int</FONT></B> get2 = get(2 * id + 1, mid + 1, r, u, v);
        <B><FONT COLOR="#A020F0">if</FONT></B> (get1 == -inf) <B><FONT COLOR="#A020F0">return</FONT></B> get2;
        <B><FONT COLOR="#A020F0">if</FONT></B> (get2 == -inf) <B><FONT COLOR="#A020F0">return</FONT></B> get1;
        <B><FONT COLOR="#A020F0">return</FONT></B> height[get1] &lt; height[get2] ? get1 : get2;
    }
    

    <B><FONT COLOR="#228B22">int</FONT></B> lca(<B><FONT COLOR="#228B22">int</FONT></B> u, <B><FONT COLOR="#228B22">int</FONT></B> v) {
        <B><FONT COLOR="#228B22">int</FONT></B> left = first[u], right = first[v];
        <B><FONT COLOR="#A020F0">if</FONT></B> (left &gt; right) swap(left, right);
        <B><FONT COLOR="#A020F0">return</FONT></B> get(1, 0, sz(euler) - 1, left, right);
    }
};

<I><FONT COLOR="#B22222">// Method 2: Binary Lifting 
</FONT></I><I><FONT COLOR="#B22222">// init up
</FONT></I><B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">dfs</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> u) {
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> v : g[u]) {
        <B><FONT COLOR="#A020F0">if</FONT></B> (v == up[u][0]) <B><FONT COLOR="#A020F0">continue</FONT></B>;
        h[v] = h[u] + 1;
        
        up[v][0] = u;
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 1; j &lt; 20; ++j)
            up[v][j] = up[up[v][j - 1]][j - 1];

        dfs(v);
    }
}

<B><FONT COLOR="#228B22">int</FONT></B> h[N], up[N][20];
<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">lca</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> u, <B><FONT COLOR="#228B22">int</FONT></B> v) {
    <B><FONT COLOR="#A020F0">if</FONT></B> (h[u] != h[v]) {
        <B><FONT COLOR="#A020F0">if</FONT></B> (h[u] &lt; h[v]) swap(u, v);
    
        <I><FONT COLOR="#B22222">// find ancestor u' of u in which h(u') = h(v)
</FONT></I>        <B><FONT COLOR="#228B22">int</FONT></B> k = h[u] - h[v];
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 0; (1 &lt;&lt; j) &lt;= k; ++j)
            <B><FONT COLOR="#A020F0">if</FONT></B> (k &gt;&gt; j &amp; 1) <I><FONT COLOR="#B22222">// if jth bit of k is 1
</FONT></I>                u = up[u][j];
    }
    <B><FONT COLOR="#A020F0">if</FONT></B> (u == v) <B><FONT COLOR="#A020F0">return</FONT></B> u;
    
    <I><FONT COLOR="#B22222">// Find LCA(u,v)
</FONT></I>    <B><FONT COLOR="#228B22">int</FONT></B> k = __lg(h[u]);
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = k; j &gt;= 0; --j)
        <B><FONT COLOR="#A020F0">if</FONT></B> (up[u][j] != up[v][j]) <I><FONT COLOR="#B22222">// if (1&lt;&lt;j)th ancestors of u and v are different
</FONT></I>            u = up[u][j], v = up[v][j];
    <B><FONT COLOR="#A020F0">return</FONT></B> up[u][0];
}

<I><FONT COLOR="#B22222">// Properties
</FONT></I><I><FONT COLOR="#B22222">/*
1. lca(v1, v2) lies on a shortest path from v1 and v2
2. dist(a, b) = depth(a) + depth(b) - 2depth(c) where c = lca(a, b)
3. if v1 is ancestor of v2 =&gt; lca(v1,v2) = v1
*/</FONT></I></PRE>
<HR>
<A NAME="file30">
<H1>code/tree/eulertour.cc 30/70</H1>
[<A HREF="#top">top</A>][<A HREF="#file29">prev</A>][<A HREF="#file31">next</A>]
<PRE>
<I><FONT COLOR="#B22222">/**
 * Description: Euler tour. Using dfs traversal to flatten out tree in an array 
 * where each subtree is represented by a range. Use with BIT or segtree for subtree 
 * queries
 */</FONT></I>

vector&lt;vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt;&gt; g(maxn);
vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; start;
vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; en;
<B><FONT COLOR="#228B22">int</FONT></B> timer = 0;

<I><FONT COLOR="#B22222">// tour or tree traversal array will be 0-based (which will be used to construct FT or segtree)
</FONT></I><I><FONT COLOR="#B22222">// Node: tree traversal array is just a record of the first occurence of a node in an euler tour/path
</FONT></I><B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">euler_tour</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> at, <B><FONT COLOR="#228B22">int</FONT></B> prev) {
	start[at] = timer++;
	<B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> n : g[at]) {
		<B><FONT COLOR="#A020F0">if</FONT></B> (n != prev) { euler_tour(n, at); }
	}
	en[at] = timer;
}

start.resize(node_num);
en.resize(node_num);
<B><FONT COLOR="#0000FF">euler_tour</FONT></B>(0, -1);

<I><FONT COLOR="#B22222">/*
[start[i], en[i] - 1] is the subtree root i. en[i] - start[i] is the subtree size
*/</FONT></I>

<I><FONT COLOR="#B22222">// Generally when doing euler tour, we should use 0-based node 
</FONT></I><I><FONT COLOR="#B22222">// Complete Euler path</FONT></I></PRE>
<HR>
<A NAME="file31">
<H1>code/tree/binlift.cc 31/70</H1>
[<A HREF="#top">top</A>][<A HREF="#file30">prev</A>][<A HREF="#file32">next</A>]
<PRE>
<I><FONT COLOR="#B22222">/**
 * Description: Binary Lifting, find kth ancestor of a node in a tree
 */</FONT></I>

<B><FONT COLOR="#228B22">int</FONT></B> par[N], up[N][17];
<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">preprocess</FONT></B>() {
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> u = 1; u &lt;= n; ++u) up[u][0] = par[u];
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 1; j &lt; 17; ++j)
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> u = 1; u &lt;= n; ++u)
            up[u][j] = up[up[u][j - 1]][j - 1];
}

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">ancestor_k</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> u, <B><FONT COLOR="#228B22">int</FONT></B> k) {
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 0; (1 &lt;&lt; j) &lt;= k; ++j)
        <B><FONT COLOR="#A020F0">if</FONT></B> (k &gt;&gt; j &amp; 1) u = up[u][j];
    <B><FONT COLOR="#A020F0">return</FONT></B> u;
}

<I><FONT COLOR="#B22222">/**
 * Description: find the furthest ancestor of a node in which dist &lt;= x
 * Time: O(N/logN + Q\log^{2}N)
 */</FONT></I>

<I><FONT COLOR="#B22222">// Algo 1
</FONT></I><B><FONT COLOR="#228B22">int</FONT></B> dist[N][17];
<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">calc_dist</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> u, <B><FONT COLOR="#228B22">int</FONT></B> k) {
    <B><FONT COLOR="#228B22">int</FONT></B> sum = 0;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 0; (1 &lt;&lt; j) &lt;= k; ++j)
        <B><FONT COLOR="#A020F0">if</FONT></B> (k &gt;&gt; j &amp; 1) {
            sum += dist[u][j];
            u = up[u][j];
        }
    <B><FONT COLOR="#A020F0">return</FONT></B> sum;
}

    <I><FONT COLOR="#B22222">// binary search to find ans
</FONT></I><B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">solve</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> u, <B><FONT COLOR="#228B22">int</FONT></B> x) {
    <B><FONT COLOR="#228B22">int</FONT></B> lo = 0, hi = h[u], mid, ans = 0;
    <B><FONT COLOR="#A020F0">while</FONT></B> (lo &lt;= hi) {
        mid = (lo + hi) / 2;
        <B><FONT COLOR="#A020F0">if</FONT></B> (calc_dist(u, mid) &lt;= x) {
            ans = mid;    
            lo = mid + 1;
        }
        <B><FONT COLOR="#A020F0">else</FONT></B> hi = mid - 1;
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> ancestor_k(u, ans);
}

<I><FONT COLOR="#B22222">// Algo 2 (Efficient)
</FONT></I><B><FONT COLOR="#228B22">int</FONT></B> dist[N][17];
<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">solve</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> u, <B><FONT COLOR="#228B22">int</FONT></B> x) {
    <B><FONT COLOR="#228B22">int</FONT></B> now_dist = 0, k = 0;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = __lg(h[u]); j &gt;= 0; --j) {
        <B><FONT COLOR="#A020F0">if</FONT></B> (h[u] &gt;= (1 &lt;&lt; j) &amp;&amp; now_dist + dist[u][j] &lt;= x) {
            now_dist += dist[u][j];
            k |= 1 &lt;&lt; j;
            u = up[u][j];
        }
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> u;
}</PRE>
<HR>
<A NAME="file32">
<H1>code/geometry/point.cc 32/70</H1>
[<A HREF="#top">top</A>][<A HREF="#file31">prev</A>][<A HREF="#file33">next</A>]
<PRE>
<I><FONT COLOR="#B22222">/**
 * Description: Point Struct
 */</FONT></I>

<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> INF = 1e9;
<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> EPS = 1e-9;

<I><FONT COLOR="#B22222">// const double PI = acos(-1.0) or 2.0 * acos(0.0) for alternative to M_PI
</FONT></I><B><FONT COLOR="#228B22">double</FONT></B> <B><FONT COLOR="#0000FF">DEG_to_RAD</FONT></B>(<B><FONT COLOR="#228B22">double</FONT></B> d) { <B><FONT COLOR="#A020F0">return</FONT></B> d*M_PI/180.0; }

<B><FONT COLOR="#228B22">double</FONT></B> <B><FONT COLOR="#0000FF">RAD_to_DEG</FONT></B>(<B><FONT COLOR="#228B22">double</FONT></B> r) { <B><FONT COLOR="#A020F0">return</FONT></B> r*180.0/M_PI; }

<B><FONT COLOR="#228B22">struct</FONT></B> point_i {
    <B><FONT COLOR="#228B22">int</FONT></B> x, y;                                      <I><FONT COLOR="#B22222">// use this if possible
</FONT></I>    point_i() { x = y = 0; }                       <I><FONT COLOR="#B22222">// default constructor
</FONT></I>    point_i(<B><FONT COLOR="#228B22">int</FONT></B> _x, <B><FONT COLOR="#228B22">int</FONT></B> _y) : x(_x), y(_y) {}      <I><FONT COLOR="#B22222">// constructor
</FONT></I>};

<I><FONT COLOR="#B22222">// check the required precision and set EPS appropriately.
</FONT></I><B><FONT COLOR="#228B22">struct</FONT></B> point {
    <B><FONT COLOR="#228B22">double</FONT></B> x, y;                                   <I><FONT COLOR="#B22222">// if need more precision
</FONT></I>    point() { x = y = 0.0; }                       <I><FONT COLOR="#B22222">// default constructor
</FONT></I>    point(<B><FONT COLOR="#228B22">double</FONT></B> _x, <B><FONT COLOR="#228B22">double</FONT></B> _y) : x(_x), y(_y) {}  <I><FONT COLOR="#B22222">// constructor
</FONT></I>    <B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#A020F0">operator</FONT></B> &lt; (point other) <B><FONT COLOR="#228B22">const</FONT></B> {          <I><FONT COLOR="#B22222">// override &lt; operator
</FONT></I>        <B><FONT COLOR="#A020F0">if</FONT></B> (fabs(x-other.x) &gt; EPS)                 <I><FONT COLOR="#B22222">// useful for sorting
</FONT></I>            <B><FONT COLOR="#A020F0">return</FONT></B> x &lt; other.x;                    <I><FONT COLOR="#B22222">// by x-coordinate
</FONT></I>        <B><FONT COLOR="#A020F0">return</FONT></B> y &lt; other.y;                        <I><FONT COLOR="#B22222">// if tie, by y-coordinate
</FONT></I>    }
    <I><FONT COLOR="#B22222">// use EPS (1e-9) when testing equality of two floating points
</FONT></I>    <B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#A020F0">operator</FONT></B> == (<B><FONT COLOR="#228B22">const</FONT></B> point &amp;other) <B><FONT COLOR="#228B22">const</FONT></B> {
        <B><FONT COLOR="#A020F0">return</FONT></B> (fabs(x-other.x) &lt; EPS &amp;&amp; (fabs(y-other.y) &lt; EPS));
    }
};

<B><FONT COLOR="#228B22">double</FONT></B> <B><FONT COLOR="#0000FF">dist</FONT></B>(point p1, point p2) {                  <I><FONT COLOR="#B22222">// Euclidean distance
</FONT></I>    <I><FONT COLOR="#B22222">// hypot(dx, dy) returns sqrt(dx*dx + dy*dy)
</FONT></I>    <B><FONT COLOR="#A020F0">return</FONT></B> hypot(p1.x-p2.x, p1.y-p2.y);            <I><FONT COLOR="#B22222">// return double
</FONT></I>}

<I><FONT COLOR="#B22222">// rotate p by theta degrees CCW w.r.t origin (0, 0)
</FONT></I>point <B><FONT COLOR="#0000FF">rotate</FONT></B>(point p, <B><FONT COLOR="#228B22">double</FONT></B> theta) {              <I><FONT COLOR="#B22222">// theta in degrees
</FONT></I>    <B><FONT COLOR="#228B22">double</FONT></B> rad = DEG_to_RAD(theta);                <I><FONT COLOR="#B22222">// convert to radian
</FONT></I>    <B><FONT COLOR="#A020F0">return</FONT></B> point(p.x*cos(rad) - p.y*sin(rad),
                p.x*sin(rad) + p.y*cos(rad));
}</PRE>
<HR>
<A NAME="file33">
<H1>code/geometry/line.cc 33/70</H1>
[<A HREF="#top">top</A>][<A HREF="#file32">prev</A>][<A HREF="#file34">next</A>]
<PRE>
<I><FONT COLOR="#B22222">/**
 * Description: Line Struct
 */</FONT></I>

<I><FONT COLOR="#B22222">/*
A line in 2D Euclidean space is the set of points whose coordinates satisfy 
a given linear equation  ax + by + c = 0. This linear equation has b = 1 for 
non-vertical lines and b = 0 for vertical lines unless otherwise stated.
*/</FONT></I>

<B><FONT COLOR="#228B22">struct</FONT></B> line { <B><FONT COLOR="#228B22">double</FONT></B> a, b, c; };                 <I><FONT COLOR="#B22222">// most versatile
</FONT></I>
<I><FONT COLOR="#B22222">// We can compute the line equation if we are given at least two points on that line via the following function.
</FONT></I><I><FONT COLOR="#B22222">// the answer is stored in the third parameter (pass by reference)
</FONT></I><B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">pointsToLine</FONT></B>(point p1, point p2, line &amp;l) {
    <B><FONT COLOR="#A020F0">if</FONT></B> (fabs(p1.x-p2.x) &lt; EPS)                     <I><FONT COLOR="#B22222">// vertical line is fine
</FONT></I>        l = {1.0, 0.0, -p1.x};                       <I><FONT COLOR="#B22222">// default values
</FONT></I>    <B><FONT COLOR="#A020F0">else</FONT></B> {
        <B><FONT COLOR="#228B22">double</FONT></B> a = -(<B><FONT COLOR="#228B22">double</FONT></B>)(p1.y-p2.y) / (p1.x-p2.x);
        l = {a, 1.0, -(<B><FONT COLOR="#228B22">double</FONT></B>)(a*p1.x) - p1.y};      <I><FONT COLOR="#B22222">// NOTE: b always 1.0
</FONT></I>    }
}

<I><FONT COLOR="#B22222">// convert point and gradient/slope to line, not for vertical line
</FONT></I><B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">pointSlopeToLine</FONT></B>(point p, <B><FONT COLOR="#228B22">double</FONT></B> m, line &amp;l) { <I><FONT COLOR="#B22222">// m &lt; Inf
</FONT></I>    l.a = -m;                                   <I><FONT COLOR="#B22222">// always -m
</FONT></I>    l.b = 1.0;                                  <I><FONT COLOR="#B22222">// always 1.0
</FONT></I>    l.c = -((l.a * p.x) + (l.b * p.y));         <I><FONT COLOR="#B22222">// compute this
</FONT></I>}

<B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">areParallel</FONT></B>(line l1, line l2) {             <I><FONT COLOR="#B22222">// check a and b
</FONT></I>    <B><FONT COLOR="#A020F0">return</FONT></B> (fabs(l1.a-l2.a) &lt; EPS) &amp;&amp; (fabs(l1.b-l2.b) &lt; EPS);
}

<B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">areSame</FONT></B>(line l1, line l2) {                 <I><FONT COLOR="#B22222">// also check  c
</FONT></I>    <B><FONT COLOR="#A020F0">return</FONT></B> areParallel(l1 ,l2) &amp;&amp; (fabs(l1.c-l2.c) &lt; EPS);
}

<I><FONT COLOR="#B22222">// returns true (+ intersection point p) if two lines are intersect
</FONT></I><B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">areIntersect</FONT></B>(line l1, line l2, point &amp;p) {
    <B><FONT COLOR="#A020F0">if</FONT></B> (areParallel(l1, l2)) <B><FONT COLOR="#A020F0">return</FONT></B> false;         <I><FONT COLOR="#B22222">// no intersection
</FONT></I>    <I><FONT COLOR="#B22222">// solve system of 2 linear algebraic equations with 2 unknowns
</FONT></I>    p.x = (l2.b*l1.c - l1.b*l2.c) / (l2.a*l1.b - l1.a*l2.b);
    <I><FONT COLOR="#B22222">// special case: test for vertical line to avoid division by zero
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B> (fabs(l1.b) &gt; EPS) p.y = -(l1.a*p.x + l1.c);
    <B><FONT COLOR="#A020F0">else</FONT></B>                  p.y = -(l2.a*p.x + l2.c);
    <B><FONT COLOR="#A020F0">return</FONT></B> true;
}

</PRE>
<HR>
<A NAME="file34">
<H1>code/geometry/vector.cc 34/70</H1>
[<A HREF="#top">top</A>][<A HREF="#file33">prev</A>][<A HREF="#file35">next</A>]
<PRE>
<I><FONT COLOR="#B22222">/**
 * Description: Vector
 */</FONT></I>

<B><FONT COLOR="#228B22">struct</FONT></B> vec { <B><FONT COLOR="#228B22">double</FONT></B> x, y; <I><FONT COLOR="#B22222">// name: `vec' is different from STL vector
</FONT></I>  vec(<B><FONT COLOR="#228B22">double</FONT></B> _x, <B><FONT COLOR="#228B22">double</FONT></B> _y) : x(_x), y(_y) {}
};

vec <B><FONT COLOR="#0000FF">toVec</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> point &amp;a, <B><FONT COLOR="#228B22">const</FONT></B> point &amp;b) {      <I><FONT COLOR="#B22222">// convert 2 points
</FONT></I>  <B><FONT COLOR="#A020F0">return</FONT></B> vec(b.x-a.x, b.y-a.y);                  <I><FONT COLOR="#B22222">// to vector a-&gt;b
</FONT></I>}

vec <B><FONT COLOR="#0000FF">scale</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> vec &amp;v, <B><FONT COLOR="#228B22">double</FONT></B> s) {
  <B><FONT COLOR="#A020F0">return</FONT></B> vec(v.x*s, v.y*s);
}

point <B><FONT COLOR="#0000FF">translate</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> point &amp;p, <B><FONT COLOR="#228B22">const</FONT></B> vec &amp;v) {  <I><FONT COLOR="#B22222">// translate p
</FONT></I>  <B><FONT COLOR="#A020F0">return</FONT></B> point(p.x+v.x, p.y+v.y);                <I><FONT COLOR="#B22222">// according to v
</FONT></I>}
<I><FONT COLOR="#B22222">// return a new point
</FONT></I>
<I><FONT COLOR="#B22222">// returns the dot product of two vectors a and b
</FONT></I><B><FONT COLOR="#228B22">double</FONT></B> <B><FONT COLOR="#0000FF">dot</FONT></B>(vec a, vec b) { <B><FONT COLOR="#A020F0">return</FONT></B> (a.x*b.x + a.y*b.y); }

<I><FONT COLOR="#B22222">// returns the squared value of the normalized vector
</FONT></I><B><FONT COLOR="#228B22">double</FONT></B> <B><FONT COLOR="#0000FF">norm_sq</FONT></B>(vec v) { <B><FONT COLOR="#A020F0">return</FONT></B> v.x*v.x + v.y*v.y; }

<B><FONT COLOR="#228B22">double</FONT></B> <B><FONT COLOR="#0000FF">angle</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> point &amp;a, <B><FONT COLOR="#228B22">const</FONT></B> point &amp;o, <B><FONT COLOR="#228B22">const</FONT></B> point &amp;b) {
  vec oa = toVec(o, a), ob = toVec(o, b);        <I><FONT COLOR="#B22222">// a != o != b
</FONT></I>  <B><FONT COLOR="#A020F0">return</FONT></B> acos(dot(oa, ob) / sqrt(norm_sq(oa) * norm_sq(ob)));
}                                                <I><FONT COLOR="#B22222">// angle aob in rad
</FONT></I>
<I><FONT COLOR="#B22222">// returns the distance from p to the line defined by
</FONT></I><I><FONT COLOR="#B22222">// two points a and b (a and b must be different)
</FONT></I><I><FONT COLOR="#B22222">// the closest point is stored in the 4th parameter (byref)
</FONT></I><B><FONT COLOR="#228B22">double</FONT></B> <B><FONT COLOR="#0000FF">distToLine</FONT></B>(point p, point a, point b, point &amp;c) {
  vec ap = toVec(a, p), ab = toVec(a, b);
  <B><FONT COLOR="#228B22">double</FONT></B> u = dot(ap, ab) / norm_sq(ab);
  <I><FONT COLOR="#B22222">// formula: c = a + u*ab
</FONT></I>  c = translate(a, scale(ab, u));                <I><FONT COLOR="#B22222">// translate a to c
</FONT></I>  <B><FONT COLOR="#A020F0">return</FONT></B> dist(p, c);                             <I><FONT COLOR="#B22222">// Euclidean distance
</FONT></I>}

<I><FONT COLOR="#B22222">// returns the distance from p to the line segment ab defined by
</FONT></I><I><FONT COLOR="#B22222">// two points a and b (technically, a has to be different than b)
</FONT></I><I><FONT COLOR="#B22222">// the closest point is stored in the 4th parameter (byref)
</FONT></I><B><FONT COLOR="#228B22">double</FONT></B> <B><FONT COLOR="#0000FF">distToLineSegment</FONT></B>(point p, point a, point b, point &amp;c) {
  vec ap = toVec(a, p), ab = toVec(a, b);
  <B><FONT COLOR="#228B22">double</FONT></B> u = dot(ap, ab) / norm_sq(ab);
  <B><FONT COLOR="#A020F0">if</FONT></B> (u &lt; 0.0) {                                 <I><FONT COLOR="#B22222">// closer to a
</FONT></I>    c = point(a.x, a.y);
    <B><FONT COLOR="#A020F0">return</FONT></B> dist(p, a);                           <I><FONT COLOR="#B22222">// dist p to a
</FONT></I>  }
  <B><FONT COLOR="#A020F0">if</FONT></B> (u &gt; 1.0) {                                 <I><FONT COLOR="#B22222">// closer to b
</FONT></I>    c = point(b.x, b.y);
    <B><FONT COLOR="#A020F0">return</FONT></B> dist(p, b);                           <I><FONT COLOR="#B22222">// dist p to b
</FONT></I>  }
  <B><FONT COLOR="#A020F0">return</FONT></B> distToLine(p, a, b, c);                 <I><FONT COLOR="#B22222">// use distToLine
</FONT></I>}

<I><FONT COLOR="#B22222">// returns the cross product of two vectors a and b
</FONT></I><B><FONT COLOR="#228B22">double</FONT></B> <B><FONT COLOR="#0000FF">cross</FONT></B>(vec a, vec b) { <B><FONT COLOR="#A020F0">return</FONT></B> a.x*b.y - a.y*b.x; }

<I><FONT COLOR="#B22222">// note: to accept collinear points, we have to change the `&gt; 0'
</FONT></I><I><FONT COLOR="#B22222">// returns true if point r is on the left side of line pq
</FONT></I><B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">ccw</FONT></B>(point p, point q, point r) {
  <B><FONT COLOR="#A020F0">return</FONT></B> cross(toVec(p, q), toVec(p, r)) &gt; -EPS;
}

<I><FONT COLOR="#B22222">// returns true if point r is on the same line as the line pq
</FONT></I><B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">collinear</FONT></B>(point p, point q, point r) {
  <B><FONT COLOR="#A020F0">return</FONT></B> fabs(cross(toVec(p, q), toVec(p, r))) &lt; EPS;
}

<I><FONT COLOR="#B22222">// convert point and gradient/slope to line
</FONT></I><B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">pointSlopeToLine</FONT></B>(point p, <B><FONT COLOR="#228B22">double</FONT></B> m, line &amp;l) {
  l.a = -m;                                      <I><FONT COLOR="#B22222">// always -m
</FONT></I>  l.b = 1;                                       <I><FONT COLOR="#B22222">// always 1
</FONT></I>  l.c = -((l.a * p.x) + (l.b * p.y));            <I><FONT COLOR="#B22222">// compute this
</FONT></I>}

<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">closestPoint</FONT></B>(line l, point p, point &amp;ans) {
  <I><FONT COLOR="#B22222">// this line is perpendicular to l and pass through p
</FONT></I>  line perpendicular;                            
  <B><FONT COLOR="#A020F0">if</FONT></B> (fabs(l.b) &lt; EPS) {                         <I><FONT COLOR="#B22222">// vertical line
</FONT></I>    ans.x = -(l.c);
    ans.y = p.y;
    <B><FONT COLOR="#A020F0">return</FONT></B>;
  }
  <B><FONT COLOR="#A020F0">if</FONT></B> (fabs(l.a) &lt; EPS) {                         <I><FONT COLOR="#B22222">// horizontal line
</FONT></I>    ans.x = p.x;
    ans.y = -(l.c);
    <B><FONT COLOR="#A020F0">return</FONT></B>;
  }
  pointSlopeToLine(p, 1/l.a, perpendicular);     <I><FONT COLOR="#B22222">// normal line
</FONT></I>  <I><FONT COLOR="#B22222">// intersect line l with this perpendicular line
</FONT></I>  <I><FONT COLOR="#B22222">// the intersection point is the closest point
</FONT></I>  areIntersect(l, perpendicular, ans);
}

<I><FONT COLOR="#B22222">// returns the reflection of point on a line
</FONT></I><B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">reflectionPoint</FONT></B>(line l, point p, point &amp;ans) {
  point b;
  closestPoint(l, p, b);                         <I><FONT COLOR="#B22222">// similar to distToLine
</FONT></I>  vec v = toVec(p, b);                           <I><FONT COLOR="#B22222">// create a vector
</FONT></I>  ans = translate(translate(p, v), v);           <I><FONT COLOR="#B22222">// translate p twice
</FONT></I>}
</PRE>
<HR>
<A NAME="file35">
<H1>code/geometry/complex.cc 35/70</H1>
[<A HREF="#top">top</A>][<A HREF="#file34">prev</A>][<A HREF="#file36">next</A>]
<PRE>
<I><FONT COLOR="#B22222">/**
 * Description: use complex number to represent points and vector
 */</FONT></I>

<I><FONT COLOR="#B22222">// define x, y as real(), imag()
</FONT></I><B><FONT COLOR="#228B22">typedef</FONT></B> <B><FONT COLOR="#228B22">complex</FONT></B>&lt;<B><FONT COLOR="#228B22">double</FONT></B>&gt; point;
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">x</FONT> real()
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">y</FONT> imag()
<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> pi = acos(-1.0);
<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">double</FONT></B> EPS = 1e-9;

#<B><FONT COLOR="#5F9EA0">define</FONT></B> <B><FONT COLOR="#0000FF">P</FONT></B>(p) const point &amp;p
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <B><FONT COLOR="#0000FF">L</FONT></B>(p0, p1) P(p0), P(p1)
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <B><FONT COLOR="#0000FF">C</FONT></B>(p0, r) P(p0), double r
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <B><FONT COLOR="#0000FF">PP</FONT></B>(pp) pair&lt;point,point&gt; &amp;pp

<I><FONT COLOR="#B22222">// Note: std::complex has issues with integral data types. The library will work 
</FONT></I><I><FONT COLOR="#B22222">// for simple arithmetic like vector addition and such, but not for polar or abs. 
</FONT></I><I><FONT COLOR="#B22222">// It will compile but there will be some errors in correctness! The tip then is 
</FONT></I><I><FONT COLOR="#B22222">// to rely on the library only if you're using floating point data all throughout.
</FONT></I>
<B><FONT COLOR="#228B22">double</FONT></B> <B><FONT COLOR="#0000FF">dot</FONT></B>(P(a), P(b)) { 
    <B><FONT COLOR="#A020F0">return</FONT></B> real(conj(a) * b); 
}

<I><FONT COLOR="#B22222">// x1y2-x2y1
</FONT></I><I><FONT COLOR="#B22222">// The cross product tells us whether b turns left (positive value), 
</FONT></I><I><FONT COLOR="#B22222">// does not turn (zero) or turns right (negative value) when it is placed
</FONT></I><I><FONT COLOR="#B22222">// directly after a
</FONT></I><B><FONT COLOR="#228B22">double</FONT></B> <B><FONT COLOR="#0000FF">cross</FONT></B>(P(a), P(b)) { 
    <B><FONT COLOR="#A020F0">return</FONT></B> imag(conj(a) * b); 
}

point <B><FONT COLOR="#0000FF">rotate</FONT></B>(P(p), <B><FONT COLOR="#228B22">double</FONT></B> radians = pi / 2, P(about) = point(0,0)) { 
    <B><FONT COLOR="#A020F0">return</FONT></B> (p - about) * exp(point(0, radians)) + about; 
}
point <B><FONT COLOR="#0000FF">proj</FONT></B>(P(u), P(v)) { 
    <B><FONT COLOR="#A020F0">return</FONT></B> dot(u, v) / dot(u, u) * u; 
}
point <B><FONT COLOR="#0000FF">normalize</FONT></B>(P(p), <B><FONT COLOR="#228B22">double</FONT></B> k = 1.0) { 
    <B><FONT COLOR="#A020F0">return</FONT></B> abs(p) == 0 ? point(0,0) : p / abs(p) * k; 
}
<B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">parallel</FONT></B>(L(a, b), L(p, q)) { 
    <B><FONT COLOR="#A020F0">return</FONT></B> abs(cross(b - a, q - p)) &lt; EPS; 
}
<B><FONT COLOR="#228B22">double</FONT></B> <B><FONT COLOR="#0000FF">ccw</FONT></B>(P(a), P(b), P(c)) { 
    <B><FONT COLOR="#A020F0">return</FONT></B> cross(b - a, c - b); 
}
<B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">collinear</FONT></B>(P(a), P(b), P(c)) { <B><FONT COLOR="#A020F0">return</FONT></B> abs(ccw(a, b, c)) &lt; EPS; }
<B><FONT COLOR="#228B22">double</FONT></B> <B><FONT COLOR="#0000FF">angle</FONT></B>(P(a), P(b), P(c)) {
    <B><FONT COLOR="#A020F0">return</FONT></B> acos(dot(b - a, c - b) / abs(b - a) / abs(c - b)); 
}
<B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">intersect</FONT></B>(L(a, b), L(p, q), point &amp;res, <B><FONT COLOR="#228B22">bool</FONT></B> segment = false) {
    <I><FONT COLOR="#B22222">// NOTE: check for parallel/collinear lines before calling this function
</FONT></I>    point r = b - a, s = q - p;
    <B><FONT COLOR="#228B22">double</FONT></B> c = cross(r, s), t = cross(p - a, s) / c, u = cross(p - a, r) / c;
    <B><FONT COLOR="#A020F0">if</FONT></B> (segment &amp;&amp; (t &lt; 0-EPS || t &gt; 1+EPS || u &lt; 0-EPS || u &gt; 1+EPS))
        <B><FONT COLOR="#A020F0">return</FONT></B> false;
    res = a + t * r;
    <B><FONT COLOR="#A020F0">return</FONT></B> true;
}
point <B><FONT COLOR="#0000FF">closest_point</FONT></B>(L(a, b), P(c), <B><FONT COLOR="#228B22">bool</FONT></B> segment = false) {
    <B><FONT COLOR="#A020F0">if</FONT></B> (segment) {
        <B><FONT COLOR="#A020F0">if</FONT></B> (dot(b - a, c - b) &gt; 0) <B><FONT COLOR="#A020F0">return</FONT></B> b;
        <B><FONT COLOR="#A020F0">if</FONT></B> (dot(a - b, c - a) &gt; 0) <B><FONT COLOR="#A020F0">return</FONT></B> a;
    }
    <B><FONT COLOR="#228B22">double</FONT></B> t = dot(c - a, b - a) / norm(b - a);
    <B><FONT COLOR="#A020F0">return</FONT></B> a + t * (b - a);
}

<B><FONT COLOR="#228B22">typedef</FONT></B> vector&lt;point&gt; polygon;
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">MAXN</FONT> 1000
point hull[MAXN];
<B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">cmp</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> point &amp;a, <B><FONT COLOR="#228B22">const</FONT></B> point &amp;b) {
    <B><FONT COLOR="#A020F0">return</FONT></B> abs(real(a) - real(b)) &gt; EPS ?
        real(a) &lt; real(b) : imag(a) &lt; imag(b); }
<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">convex_hull</FONT></B>(vector&lt;point&gt; p) {
    <B><FONT COLOR="#228B22">int</FONT></B> n = p.size(), l = 0;
    sort(p.begin(), p.end(), cmp);
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; n; i++) {
        <B><FONT COLOR="#A020F0">if</FONT></B> (i &gt; 0 &amp;&amp; p[i] == p[i - 1])
            <B><FONT COLOR="#A020F0">continue</FONT></B>;
        <B><FONT COLOR="#A020F0">while</FONT></B> (l &gt;= 2 &amp;&amp; ccw(hull[l - 2], hull[l - 1], p[i]) &gt;= 0)
            l--;
        hull[l++] = p[i];
    }
    <B><FONT COLOR="#228B22">int</FONT></B> r = l;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = n - 2; i &gt;= 0; i--) {
        <B><FONT COLOR="#A020F0">if</FONT></B> (p[i] == p[i + 1])
            <B><FONT COLOR="#A020F0">continue</FONT></B>;
        <B><FONT COLOR="#A020F0">while</FONT></B> (r - l &gt;= 1 &amp;&amp; ccw(hull[r - 2], hull[r - 1], p[i]) &gt;= 0)
            r--;
        hull[r++] = p[i];
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> l == 1 ? 1 : r - 1;
}

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {
	point a = 2;
	point b(3, 7);
	cout &lt;&lt; a &lt;&lt; <B><FONT COLOR="#BC8F8F">' '</FONT></B> &lt;&lt; b &lt;&lt; endl; <I><FONT COLOR="#B22222">// (2, 0) (3, 7)
</FONT></I>	cout &lt;&lt; a + b &lt;&lt; endl;         <I><FONT COLOR="#B22222">// (5, 7)
</FONT></I>
	point v = {3,1};
	point u = {2,2};
	point s = v+u;
	cout &lt;&lt; s.x &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B> &lt;&lt; s.y &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;\n&quot;</FONT></B>; <I><FONT COLOR="#B22222">// 5 3
</FONT></I>
	point a = {4,2};
	point b = {3,-1};
	cout &lt;&lt; abs(b-a) &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;\n&quot;</FONT></B>; <I><FONT COLOR="#B22222">// distance between points 
</FONT></I>
	<I><FONT COLOR="#B22222">// A vector can be rotated by an angle a by multiplying it by a vector with length 1 and angle a.
</FONT></I>	P v = {4,2};
	cout &lt;&lt; arg(v) &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;\n&quot;</FONT></B>; <I><FONT COLOR="#B22222">// 0.463648
</FONT></I>	v *= polar(1.0,0.5);
	cout &lt;&lt; arg(v) &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;\n&quot;</FONT></B>; <I><FONT COLOR="#B22222">// 0.963648
</FONT></I>}

<I><FONT COLOR="#B22222">// If the input coordinates are integer, 
</FONT></I><I><FONT COLOR="#B22222">// most computations can be done in integers, 
</FONT></I><I><FONT COLOR="#B22222">// but the result may be real (for example, in line intersection, as we'll see later). 
</FONT></I><I><FONT COLOR="#B22222">// So, it's useful to have different point types in one program. And here's the first advice: 
</FONT></I><I><FONT COLOR="#B22222">// do computations in integers as long as possible, for two obvious reasons:
</FONT></I><I><FONT COLOR="#B22222">// they are faster; they avoid precision issues.</FONT></I></PRE>
<HR>
<A NAME="file36">
<H1>code/geometry/circle.cc 36/70</H1>
[<A HREF="#top">top</A>][<A HREF="#file35">prev</A>][<A HREF="#file37">next</A>]
<PRE>
<I><FONT COLOR="#B22222">/**
 * Description: Circle
 */</FONT></I>

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">insideCircle</FONT></B>(point_i p, point_i c, <B><FONT COLOR="#228B22">int</FONT></B> r) {  <I><FONT COLOR="#B22222">// all integer version
</FONT></I>  <B><FONT COLOR="#228B22">int</FONT></B> dx = p.x-c.x, dy = p.y-c.y;
  <B><FONT COLOR="#228B22">int</FONT></B> Euc = dx*dx + dy*dy, rSq = r*r;            <I><FONT COLOR="#B22222">// all integer
</FONT></I>  <B><FONT COLOR="#A020F0">return</FONT></B> Euc &lt; rSq ? 1 : Euc == rSq ? 0 : -1;    <I><FONT COLOR="#B22222">// inside/border/outside
</FONT></I>}

<I><FONT COLOR="#B22222">// constant pi
</FONT></I><I><FONT COLOR="#B22222">// M_PI in C++ &lt;cmath&gt; library. or use PI = arccos(-1.0) or PI = 2 * arccos(0.0).
</FONT></I><I><FONT COLOR="#B22222">// Length of arc: alpha*c/360.0 (c is circum)
</FONT></I><I><FONT COLOR="#B22222">// Length of chord: sqrt(2*r^2*(1-cos(alpha))) or 2*r*sin(alpha/2)
</FONT></I>
<I><FONT COLOR="#B22222">/*
Sector of a circle is defined as a region of the circle enclosed by two radii and an arc
lying between the two radii. A circle with area A and a central angle alpha (in degrees)
has the corresponding sector area alpha*A/360.0 
*/</FONT></I>

<I><FONT COLOR="#B22222">/*
Given 2 points on the circle (p1 and p2) and radius r of the corresponding circle, we can determine 
the location of the centers (c1 and c2) of the two possible circles
*/</FONT></I>
<B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">circle2PtsRad</FONT></B>(point p1, point p2, <B><FONT COLOR="#228B22">double</FONT></B> r, point &amp;c) {
  <I><FONT COLOR="#B22222">// to get the other center, reverse p1 and p2
</FONT></I>  <B><FONT COLOR="#228B22">double</FONT></B> d2 = (p1.x-p2.x) * (p1.x-p2.x) + 
              (p1.y-p2.y) * (p1.y-p2.y);
  <B><FONT COLOR="#228B22">double</FONT></B> det = r*r / d2 - 0.25;
  <B><FONT COLOR="#A020F0">if</FONT></B> (det &lt; 0.0) <B><FONT COLOR="#A020F0">return</FONT></B> false;
  <B><FONT COLOR="#228B22">double</FONT></B> h = sqrt(det);
  c.x = (p1.x+p2.x) * 0.5 + (p1.y-p2.y) * h;
  c.y = (p1.y+p2.y) * 0.5 + (p2.x-p1.x) * h;
  <B><FONT COLOR="#A020F0">return</FONT></B> true;
}

<I><FONT COLOR="#B22222">/*
To check if three line segments of length a, b and c can form a triangle, we can simply 
check these triangle inequalities: (a+b&gt;c)&amp;&amp;(a+c&gt;b)&amp;&amp;(b+c&gt;a).
If the three lengths are sorted, with a being the smallest and c the largest, then we c
an simplify the check to just (a + b &gt; c).
*/</FONT></I>
</PRE>
<HR>
<A NAME="file37">
<H1>code/geometry/Quadrilaterals.cc 37/70</H1>
[<A HREF="#top">top</A>][<A HREF="#file36">prev</A>][<A HREF="#file38">next</A>]
<PRE>
<I><FONT COLOR="#B22222">/**
 * Description: Quadrilaterals
 */</FONT></I>

<I><FONT COLOR="#B22222">// Given a rectangle described with its bottom left corner (x, y) plus its width w and height h, 
</FONT></I><I><FONT COLOR="#B22222">// we can use the following checks to determine if another point (a, b) is inside, at the border, 
</FONT></I><I><FONT COLOR="#B22222">// or outside this rectangle:
</FONT></I><B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">insideRectangle</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> x, <B><FONT COLOR="#228B22">int</FONT></B> y, <B><FONT COLOR="#228B22">int</FONT></B> w, <B><FONT COLOR="#228B22">int</FONT></B> h, <B><FONT COLOR="#228B22">int</FONT></B> a, <B><FONT COLOR="#228B22">int</FONT></B> b)
{
    <B><FONT COLOR="#A020F0">if</FONT></B> ((x &lt; a) &amp;&amp; (a &lt; x + w) &amp;&amp; (y &lt; b) &amp;&amp; (b &lt; y + h))
        <B><FONT COLOR="#A020F0">return</FONT></B> 1; <I><FONT COLOR="#B22222">// strictly inside
</FONT></I>    <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> ((x &lt;= a) &amp;&amp; (a &lt;= x + w) &amp;&amp; (y &lt;= b) &amp;&amp; (b &lt;= y + h))
        <B><FONT COLOR="#A020F0">return</FONT></B> 0; <I><FONT COLOR="#B22222">// at border
</FONT></I>    <B><FONT COLOR="#A020F0">else</FONT></B>
        <B><FONT COLOR="#A020F0">return</FONT></B> -1; <I><FONT COLOR="#B22222">// outside
</FONT></I>}</PRE>
<HR>
<A NAME="file38">
<H1>code/geometry/triangle.cc 38/70</H1>
[<A HREF="#top">top</A>][<A HREF="#file37">prev</A>][<A HREF="#file39">next</A>]
<PRE>
<I><FONT COLOR="#B22222">/**
 * Author: Ulf Lundstrom
 * Date: 2009-02-26
 * License: CC0
 * Source: My head with inspiration from tinyKACTL
 * Description: Triangle
 * Status: Works fine, used a lot
 */</FONT></I>

<I><FONT COLOR="#B22222">/*
To check if three line segments of length a, b and c can form a triangle, we can simply 
check these triangle inequalities: (a+b&gt;c)&amp;&amp;(a+c&gt;b)&amp;&amp;(b+c&gt;a).
If the three lengths are sorted, with a being the smallest and c the largest, then we can 
simplify the check to just (a + b &gt; c).
*/</FONT></I>

<I><FONT COLOR="#B22222">// Heron: A = sqrt(s(s-a)(s-b)(s-c)) with s is nua chu vi
</FONT></I>
<I><FONT COLOR="#B22222">// A triangle with area A and semi-perimeter s has an inscribed circle (incircle) with radius r = A/s.
</FONT></I><B><FONT COLOR="#228B22">double</FONT></B> <B><FONT COLOR="#0000FF">rInCircle</FONT></B>(<B><FONT COLOR="#228B22">double</FONT></B> ab, <B><FONT COLOR="#228B22">double</FONT></B> bc, <B><FONT COLOR="#228B22">double</FONT></B> ca) {
  <B><FONT COLOR="#A020F0">return</FONT></B> area(ab, bc, ca) / (0.5 * perimeter(ab, bc, ca)); }

<B><FONT COLOR="#228B22">double</FONT></B> <B><FONT COLOR="#0000FF">rInCircle</FONT></B>(point a, point b, point c) {
  <B><FONT COLOR="#A020F0">return</FONT></B> rInCircle(dist(a, b), dist(b, c), dist(c, a)); }

<I><FONT COLOR="#B22222">// The center of incircle is the meeting point between the triangle's angle bisectors. 
</FONT></I><I><FONT COLOR="#B22222">// We can get the center if we have two angle bisectors and find their intersection point
</FONT></I><I><FONT COLOR="#B22222">// assumption: the required points/lines functions have been written
</FONT></I><I><FONT COLOR="#B22222">// returns 1 if there is an inCircle center, returns 0 otherwise
</FONT></I><I><FONT COLOR="#B22222">// if this function returns 1, ctr will be the inCircle center
</FONT></I><I><FONT COLOR="#B22222">// and r is the same as rInCircle
</FONT></I><B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">inCircle</FONT></B>(point p1, point p2, point p3, point &amp;ctr, <B><FONT COLOR="#228B22">double</FONT></B> &amp;r) {
  r = rInCircle(p1, p2, p3);
  <B><FONT COLOR="#A020F0">if</FONT></B> (fabs(r) &lt; EPS) <B><FONT COLOR="#A020F0">return</FONT></B> 0;                   <I><FONT COLOR="#B22222">// no inCircle center
</FONT></I>
  line l1, l2;                    <I><FONT COLOR="#B22222">// compute these two angle bisectors
</FONT></I>  <B><FONT COLOR="#228B22">double</FONT></B> ratio = dist(p1, p2) / dist(p1, p3);
  point p = translate(p2, scale(toVec(p2, p3), ratio / (1 + ratio)));
  pointsToLine(p1, p, l1);

  ratio = dist(p2, p1) / dist(p2, p3);
  p = translate(p1, scale(toVec(p1, p3), ratio / (1 + ratio)));
  pointsToLine(p2, p, l2);

  areIntersect(l1, l2, ctr);           <I><FONT COLOR="#B22222">// get their intersection point
</FONT></I>  <B><FONT COLOR="#A020F0">return</FONT></B> 1; }

<I><FONT COLOR="#B22222">// A triangle with 3 sides: a, b, c and area A has a circumscribed circle (circumcircle) 
</FONT></I><I><FONT COLOR="#B22222">// with radius R = abc/(4A).
</FONT></I><B><FONT COLOR="#228B22">double</FONT></B> <B><FONT COLOR="#0000FF">rCircumCircle</FONT></B>(<B><FONT COLOR="#228B22">double</FONT></B> ab, <B><FONT COLOR="#228B22">double</FONT></B> bc, <B><FONT COLOR="#228B22">double</FONT></B> ca) {
  <B><FONT COLOR="#A020F0">return</FONT></B> ab * bc * ca / (4.0 * area(ab, bc, ca)); }

<B><FONT COLOR="#228B22">double</FONT></B> <B><FONT COLOR="#0000FF">rCircumCircle</FONT></B>(point a, point b, point c) {
  <B><FONT COLOR="#A020F0">return</FONT></B> rCircumCircle(dist(a, b), dist(b, c), dist(c, a)); }

<I><FONT COLOR="#B22222">// The center of circumcircle is the meeting point between the triangle's perpendicular bisectors
</FONT></I></PRE>
<HR>
<A NAME="file39">
<H1>code/geometry/polygon.cc 39/70</H1>
[<A HREF="#top">top</A>][<A HREF="#file38">prev</A>][<A HREF="#file40">next</A>]
<PRE>
<I><FONT COLOR="#B22222">/**
 * Description: Polygon
 */</FONT></I>

<I><FONT COLOR="#B22222">// Polygon representation
</FONT></I><I><FONT COLOR="#B22222">// 6(+1) points, entered in counter clockwise order, 0-based indexing
</FONT></I>vector&lt;point&gt; P;
P.emplace_back(1, 1);                          <I><FONT COLOR="#B22222">// P0
</FONT></I>P.emplace_back(3, 3);                          <I><FONT COLOR="#B22222">// P1
</FONT></I>P.emplace_back(9, 1);                          <I><FONT COLOR="#B22222">// P2
</FONT></I>P.emplace_back(12, 4);                         <I><FONT COLOR="#B22222">// P3
</FONT></I>P.emplace_back(9, 7);                          <I><FONT COLOR="#B22222">// P4
</FONT></I>P.emplace_back(1, 7);                          <I><FONT COLOR="#B22222">// P5
</FONT></I>P.push_back(P[0]);                             <I><FONT COLOR="#B22222">// loop back, P6 = P0
</FONT></I>
<I><FONT COLOR="#B22222">// returns the perimeter of polygon P, which is the sum of
</FONT></I><I><FONT COLOR="#B22222">// Euclidian distances of consecutive line segments (polygon edges)
</FONT></I><B><FONT COLOR="#228B22">double</FONT></B> <B><FONT COLOR="#0000FF">perimeter</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> vector&lt;point&gt; &amp;P) {       <I><FONT COLOR="#B22222">// by ref for efficiency
</FONT></I>  <B><FONT COLOR="#228B22">double</FONT></B> ans = 0.0;
  <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; (<B><FONT COLOR="#228B22">int</FONT></B>)P.size()-1; ++i)      <I><FONT COLOR="#B22222">// note: P[n-1] = P[0]
</FONT></I>    ans += dist(P[i], P[i+1]);                   <I><FONT COLOR="#B22222">// as we duplicate P[0]
</FONT></I>  <B><FONT COLOR="#A020F0">return</FONT></B> ans;
}

<I><FONT COLOR="#B22222">/*
The signed area A of a (convex or concave) polygon with n vertices given in some order 
(either clockwise or counter-clockwise)
*/</FONT></I>
<I><FONT COLOR="#B22222">// returns the area of polygon P
</FONT></I><B><FONT COLOR="#228B22">double</FONT></B> <B><FONT COLOR="#0000FF">area</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> vector&lt;point&gt; &amp;P) {
  <B><FONT COLOR="#228B22">double</FONT></B> ans = 0.0;
  <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; (<B><FONT COLOR="#228B22">int</FONT></B>)P.size()-1; ++i)      <I><FONT COLOR="#B22222">// Shoelace formula
</FONT></I>    ans += (P[i].x*P[i+1].y - P[i+1].x*P[i].y);
  <B><FONT COLOR="#A020F0">return</FONT></B> fabs(ans)/2.0;                          <I><FONT COLOR="#B22222">// only do / 2.0 here
</FONT></I>}

<I><FONT COLOR="#B22222">// returns the area of polygon P, which is half the cross products
</FONT></I><I><FONT COLOR="#B22222">// of vectors defined by edge endpoints
</FONT></I><B><FONT COLOR="#228B22">double</FONT></B> <B><FONT COLOR="#0000FF">area_alternative</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> vector&lt;point&gt; &amp;P) {
  <B><FONT COLOR="#228B22">double</FONT></B> ans = 0.0; point O(0.0, 0.0);           <I><FONT COLOR="#B22222">// O = the Origin
</FONT></I>  <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; (<B><FONT COLOR="#228B22">int</FONT></B>)P.size()-1; ++i)      <I><FONT COLOR="#B22222">// sum of signed areas
</FONT></I>    ans += cross(toVec(O, P[i]), toVec(O, P[i+1]));
  <B><FONT COLOR="#A020F0">return</FONT></B> fabs(ans)/2.0;
}


<I><FONT COLOR="#B22222">// Checking if a Polygon is Convex
</FONT></I><I><FONT COLOR="#B22222">/*
We can simply check whether all three consecutive vertices of the polygon form the same turns 
(all left turns/ccw if the vertices are listed in counterclockwise order-the default setting-or 
all right turns/cw if the vertices are listed in clockwise order). If we can find at least one 
triple where this is false, then the polygon is concave.
*/</FONT></I>

<I><FONT COLOR="#B22222">// returns true if we always make the same turn
</FONT></I><I><FONT COLOR="#B22222">// while examining all the edges of the polygon one by one
</FONT></I><B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">isConvex</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> vector&lt;point&gt; &amp;P) {
  <B><FONT COLOR="#228B22">int</FONT></B> n = (<B><FONT COLOR="#228B22">int</FONT></B>)P.size();
  <I><FONT COLOR="#B22222">// a point/sz=2 or a line/sz=3 is not convex  
</FONT></I>  <B><FONT COLOR="#A020F0">if</FONT></B> (n &lt;= 3) <B><FONT COLOR="#A020F0">return</FONT></B> false;
  <B><FONT COLOR="#228B22">bool</FONT></B> firstTurn = ccw(P[0], P[1], P[2]);        <I><FONT COLOR="#B22222">// remember one result,
</FONT></I>  <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 1; i &lt; n-1; ++i)                 <I><FONT COLOR="#B22222">// compare with the others
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B> (ccw(P[i], P[i+1], P[(i+2) == n ? 1 : i+2]) != firstTurn)
      <B><FONT COLOR="#A020F0">return</FONT></B> false;                              <I><FONT COLOR="#B22222">// different -&gt; concave
</FONT></I>  <B><FONT COLOR="#A020F0">return</FONT></B> true;                                   <I><FONT COLOR="#B22222">// otherwise -&gt; convex
</FONT></I>}

<I><FONT COLOR="#B22222">// Checking if a Point is Inside a Polygon
</FONT></I><I><FONT COLOR="#B22222">// returns 1/0/-1 if point p is inside/on (vertex/edge)/outside of
</FONT></I><I><FONT COLOR="#B22222">// either convex/concave polygon P
</FONT></I><B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">insidePolygon</FONT></B>(point pt, <B><FONT COLOR="#228B22">const</FONT></B> vector&lt;point&gt; &amp;P) {
  <B><FONT COLOR="#228B22">int</FONT></B> n = (<B><FONT COLOR="#228B22">int</FONT></B>)P.size();
  <B><FONT COLOR="#A020F0">if</FONT></B> (n &lt;= 3) <B><FONT COLOR="#A020F0">return</FONT></B> -1;                         <I><FONT COLOR="#B22222">// avoid point or line
</FONT></I>  <B><FONT COLOR="#228B22">bool</FONT></B> on_polygon = false;
  <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; n-1; ++i)                  <I><FONT COLOR="#B22222">// on vertex/edge?
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B> (fabs(dist(P[i], pt) + dist(pt, P[i+1]) - dist(P[i], P[i+1])) &lt; EPS)
      on_polygon = true;
  <B><FONT COLOR="#A020F0">if</FONT></B> (on_polygon) <B><FONT COLOR="#A020F0">return</FONT></B> 0;                      <I><FONT COLOR="#B22222">// pt is on polygon
</FONT></I>  <B><FONT COLOR="#228B22">double</FONT></B> sum = 0.0;                              <I><FONT COLOR="#B22222">// first = last point
</FONT></I>  <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; n-1; ++i) {
    <B><FONT COLOR="#A020F0">if</FONT></B> (ccw(pt, P[i], P[i+1]))
      sum += angle(P[i], pt, P[i+1]);            <I><FONT COLOR="#B22222">// left turn/ccw
</FONT></I>    <B><FONT COLOR="#A020F0">else</FONT></B>
      sum -= angle(P[i], pt, P[i+1]);            <I><FONT COLOR="#B22222">// right turn/cw
</FONT></I>  }
  <B><FONT COLOR="#A020F0">return</FONT></B> fabs(sum) &gt; M_PI ? 1 : -1;              <I><FONT COLOR="#B22222">// 360d-&gt;in, 0d-&gt;out
</FONT></I>}

<I><FONT COLOR="#B22222">// compute the intersection point between line segment p-q and line A-B
</FONT></I>point <B><FONT COLOR="#0000FF">lineIntersectSeg</FONT></B>(point p, point q, point A, point B) {
  <B><FONT COLOR="#228B22">double</FONT></B> a = B.y-A.y, b = A.x-B.x, c = B.x*A.y - A.x*B.y;
  <B><FONT COLOR="#228B22">double</FONT></B> u = fabs(a*p.x + b*p.y + c);
  <B><FONT COLOR="#228B22">double</FONT></B> v = fabs(a*q.x + b*q.y + c);
  <B><FONT COLOR="#A020F0">return</FONT></B> point((p.x*v + q.x*u) / (u+v), (p.y*v + q.y*u) / (u+v));
}

<I><FONT COLOR="#B22222">// cuts polygon Q along the line formed by point A-&gt;point B (order matters)
</FONT></I><I><FONT COLOR="#B22222">// (note: the last point must be the same as the first point)
</FONT></I>vector&lt;point&gt; cutPolygon(point A, point B, <B><FONT COLOR="#228B22">const</FONT></B> vector&lt;point&gt; &amp;Q) {
  vector&lt;point&gt; P;
  <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; (<B><FONT COLOR="#228B22">int</FONT></B>)Q.size(); ++i) {
    <B><FONT COLOR="#228B22">double</FONT></B> left1 = cross(toVec(A, B), toVec(A, Q[i])), left2 = 0;
    <B><FONT COLOR="#A020F0">if</FONT></B> (i != (<B><FONT COLOR="#228B22">int</FONT></B>)Q.size()-1) left2 = cross(toVec(A, B), toVec(A, Q[i+1]));
    <B><FONT COLOR="#A020F0">if</FONT></B> (left1 &gt; -EPS) P.push_back(Q[i]);         <I><FONT COLOR="#B22222">// Q[i] is on the left
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B> (left1*left2 &lt; -EPS)                      <I><FONT COLOR="#B22222">// crosses line AB
</FONT></I>      P.push_back(lineIntersectSeg(Q[i], Q[i+1], A, B));
  }
  <B><FONT COLOR="#A020F0">if</FONT></B> (!P.empty() &amp;&amp; !(P.back() == P.front()))
    P.push_back(P.front());                      <I><FONT COLOR="#B22222">// wrap around
</FONT></I>  <B><FONT COLOR="#A020F0">return</FONT></B> P;
}</PRE>
<HR>
<A NAME="file40">
<H1>code/geometry/convexhull.cc 40/70</H1>
[<A HREF="#top">top</A>][<A HREF="#file39">prev</A>][<A HREF="#file41">next</A>]
<PRE>
<I><FONT COLOR="#B22222">/**
 * Description: Finding the Convex Hull of a Set of Points. 
 * The Convex Hull of a set of points Pts is the smallest 
 * convex polygon CH(Pts) for which each point in Pts is either 
 * on the boundary of CH(Pts) or in its interior.
 */</FONT></I>


<I><FONT COLOR="#B22222">// Graham Scan
</FONT></I>vector&lt;point&gt; CH_Graham(vector&lt;point&gt; &amp;Pts) {    <I><FONT COLOR="#B22222">// overall O(n log n)
</FONT></I>  vector&lt;point&gt; P(Pts);                          <I><FONT COLOR="#B22222">// copy all points
</FONT></I>  <B><FONT COLOR="#228B22">int</FONT></B> n = (<B><FONT COLOR="#228B22">int</FONT></B>)P.size();
  <B><FONT COLOR="#A020F0">if</FONT></B> (n &lt;= 3) {                                  <I><FONT COLOR="#B22222">// point/line/triangle
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B> (!(P[0] == P[n-1])) P.push_back(P[0]);    <I><FONT COLOR="#B22222">// corner case
</FONT></I>    <B><FONT COLOR="#A020F0">return</FONT></B> P;                                    <I><FONT COLOR="#B22222">// the CH is P itself
</FONT></I>  }

  <I><FONT COLOR="#B22222">// first, find P0 = point with lowest Y and if tie: rightmost X
</FONT></I>  <B><FONT COLOR="#228B22">int</FONT></B> P0 = min_element(P.begin(), P.end())-P.begin();
  swap(P[0], P[P0]);                             <I><FONT COLOR="#B22222">// swap P[P0] with P[0]
</FONT></I>
  <I><FONT COLOR="#B22222">// second, sort points by angle around P0, O(n log n) for this sort
</FONT></I>  sort(++P.begin(), P.end(), [&amp;](point a, point b) {
    <B><FONT COLOR="#A020F0">return</FONT></B> ccw(P[0], a, b);                      <I><FONT COLOR="#B22222">// use P[0] as the pivot
</FONT></I>  });

  <I><FONT COLOR="#B22222">// third, the ccw tests, although complex, it is just O(n)
</FONT></I>  vector&lt;point&gt; S({P[n-1], P[0], P[1]});         <I><FONT COLOR="#B22222">// initial S
</FONT></I>  <B><FONT COLOR="#228B22">int</FONT></B> i = 2;                                     <I><FONT COLOR="#B22222">// then, we check the rest
</FONT></I>  <B><FONT COLOR="#A020F0">while</FONT></B> (i &lt; n) {                                <I><FONT COLOR="#B22222">// n &gt; 3, O(n)
</FONT></I>    <B><FONT COLOR="#228B22">int</FONT></B> j = (<B><FONT COLOR="#228B22">int</FONT></B>)S.size()-1;
    <B><FONT COLOR="#A020F0">if</FONT></B> (ccw(S[j-1], S[j], P[i]))                 <I><FONT COLOR="#B22222">// CCW turn
</FONT></I>      S.push_back(P[i++]);                       <I><FONT COLOR="#B22222">// accept this point
</FONT></I>    <B><FONT COLOR="#A020F0">else</FONT></B>                                         <I><FONT COLOR="#B22222">// CW turn
</FONT></I>      S.pop_back();                              <I><FONT COLOR="#B22222">// pop until a CCW turn
</FONT></I>  }
  <B><FONT COLOR="#A020F0">return</FONT></B> S;                                      <I><FONT COLOR="#B22222">// return the result
</FONT></I>}

<I><FONT COLOR="#B22222">// Monotone Chain algorithm
</FONT></I>vector&lt;point&gt; CH_Andrew(vector&lt;point&gt; &amp;Pts) {    <I><FONT COLOR="#B22222">// overall O(n log n)
</FONT></I>  <B><FONT COLOR="#228B22">int</FONT></B> n = Pts.size(), k = 0;
  vector&lt;point&gt; H(2*n);
  sort(Pts.begin(), Pts.end());                  <I><FONT COLOR="#B22222">// sort the points by x/y
</FONT></I>  <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; n; ++i) {                  <I><FONT COLOR="#B22222">// build lower hull
</FONT></I>    <B><FONT COLOR="#A020F0">while</FONT></B> ((k &gt;= 2) &amp;&amp; !ccw(H[k-2], H[k-1], Pts[i])) --k;
    H[k++] = Pts[i];
  }
  <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = n-2, t = k+1; i &gt;= 0; --i) {       <I><FONT COLOR="#B22222">// build upper hull
</FONT></I>    <B><FONT COLOR="#A020F0">while</FONT></B> ((k &gt;= t) &amp;&amp; !ccw(H[k-2], H[k-1], Pts[i])) --k;
    H[k++] = Pts[i];
  }
  H.resize(k);
  <B><FONT COLOR="#A020F0">return</FONT></B> H;
}</PRE>
<HR>
<A NAME="file41">
<H1>code/bitwise/operation.cc 41/70</H1>
[<A HREF="#top">top</A>][<A HREF="#file40">prev</A>][<A HREF="#file42">next</A>]
<PRE>
<I><FONT COLOR="#B22222">/**
 * Description: Bitwise Trick
 */</FONT></I>


<I><FONT COLOR="#B22222">/*
x &lt;&lt; k corresponds to multiplying x by 2k
x &gt;&gt; k corresponds to dividing x by 2k rounded down to an integer.

x &amp; 1 = 1 if x is odd, = 0 if x is even
x | (1 &lt;&lt; k): sets the kth bit of x to one
x &amp; (2^k-1) = 0 &lt;=&gt; x is divisible by 2^k
~x = -x-1
x &lt;&lt; k: multiplying x by 2k
x &gt;&gt; k: dividing x by 2k rounded down to an integer.
x &amp;~(1 &lt;&lt; k): sets the kth bit of x to zero
x ^ (1 &lt;&lt; k): inverts the kth bit of x.
x &amp; (x-1): sets the last one bit of x to zero
x &amp; -x: sets all the one bits to zero, except for the last one bit
x | (x-1): inverts all the bits after the last one bit

T = ((S) &amp; -(S)): get the value of the least significant bit of S that is on. 
T = LSOne(S) is a power of 2, i.e., 2^j. To get the actual index j (from the right), 
we can use __builtin_ctz(T)

a positive number x is a power of two exactly when x &amp; (x-1) = 0.

111..1 (k one bits) = 2^k-1

__builtin_clz(x): the number of zeros at the beginning of the number
__builtin_ctz(x): the number of zeros at the end of the number
__builtin_popcount(x): the number of ones in the number
__builtin_parity(x): the parity (even or odd) of the number of ones
there are also long long versions of the functions available with the suffix ll.
cout &lt;&lt; bitset&lt;8&gt;(x); prints a number after converting it into a bitset, which can be printed
*/</FONT></I>


<I><FONT COLOR="#B22222">// print a number in binary format. 
</FONT></I>string <B><FONT COLOR="#0000FF">to_binary</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> x) {
	string s;
	<B><FONT COLOR="#A020F0">while</FONT></B>(x &gt; 0) {
		s += (x % 2 ? <B><FONT COLOR="#BC8F8F">'1'</FONT></B> : <B><FONT COLOR="#BC8F8F">'0'</FONT></B>);
		x /= 2;
	}
	reverse(s.begin(), s.end());
	<B><FONT COLOR="#A020F0">return</FONT></B> s;
}



<I><FONT COLOR="#B22222">// Representing sets
</FONT></I><I><FONT COLOR="#B22222">/*
The following code declares an int variable x that can contain a subset of
{0,1,2,...,31}. After this, the code adds the elements 1, 3, 4 and 8 to the set
and prints the size of the set.
*/</FONT></I>
<B><FONT COLOR="#228B22">int</FONT></B> x = 0;
x |= (1&lt;&lt;1);
x |= (1&lt;&lt;3);
x |= (1&lt;&lt;4);
x |= (1&lt;&lt;8);
cout &lt;&lt; __builtin_popcount(x) &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;\n&quot;</FONT></B>; <I><FONT COLOR="#B22222">// 4
</FONT></I>
<B><FONT COLOR="#0000FF">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; 32; i++) {
    <B><FONT COLOR="#A020F0">if</FONT></B> (x&amp;(1&lt;&lt;i)) cout &lt;&lt; i &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>;
}
<I><FONT COLOR="#B22222">// output: 1 3 4 8
</FONT></I>
<I><FONT COLOR="#B22222">// Set operations
</FONT></I><I><FONT COLOR="#B22222">// Intersection: a &amp; b
</FONT></I><I><FONT COLOR="#B22222">// Union: a | b
</FONT></I><I><FONT COLOR="#B22222">// Complement: ~a
</FONT></I><I><FONT COLOR="#B22222">// Difference: a&amp;(~b)
</FONT></I>
<I><FONT COLOR="#B22222">//The following code first constructs the sets x = {1,3,4,8} and
</FONT></I><I><FONT COLOR="#B22222">// y = {3,6,8,9}, and then constructs the set z = xUy = {1,3,4,6,8,9}:
</FONT></I><B><FONT COLOR="#228B22">int</FONT></B> x = (1&lt;&lt;1)|(1&lt;&lt;3)|(1&lt;&lt;4)|(1&lt;&lt;8);
<B><FONT COLOR="#228B22">int</FONT></B> y = (1&lt;&lt;3)|(1&lt;&lt;6)|(1&lt;&lt;8)|(1&lt;&lt;9);
<B><FONT COLOR="#228B22">int</FONT></B> z = x|y;
cout &lt;&lt; __builtin_popcount(z) &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;\n&quot;</FONT></B>; <I><FONT COLOR="#B22222">// 6
</FONT></I>
<I><FONT COLOR="#B22222">// goes through the subsets of {0,1,...,n-1}:
</FONT></I><B><FONT COLOR="#0000FF">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> b = 0; b &lt; (1&lt;&lt;n); b++) {
    <I><FONT COLOR="#B22222">// process subset b
</FONT></I>}

<I><FONT COLOR="#B22222">// goes through the subsets with exactly k elements:
</FONT></I><B><FONT COLOR="#0000FF">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> b = 0; b &lt; (1&lt;&lt;n); b++) {
    <B><FONT COLOR="#A020F0">if</FONT></B> (__builtin_popcount(b) == k) {
        <I><FONT COLOR="#B22222">// process subset b
</FONT></I>    }
}

<I><FONT COLOR="#B22222">// goes through the subsets of a set x:
</FONT></I><B><FONT COLOR="#228B22">int</FONT></B> b = 0;
<B><FONT COLOR="#A020F0">do</FONT></B> {
    <I><FONT COLOR="#B22222">// process subset b
</FONT></I>} <B><FONT COLOR="#A020F0">while</FONT></B> (b=(b-x)&amp;x);

<I><FONT COLOR="#B22222">// Note: 2^k is just 1 << k or 1LL << k if you need long longs</FONT></I></PRE>
<HR>
<A NAME="file42">
<H1>code/bitwise/optimization.cc 42/70</H1>
[<A HREF="#top">top</A>][<A HREF="#file41">prev</A>][<A HREF="#file43">next</A>]
<PRE>
<I><FONT COLOR="#B22222">/**
 * Description: Optimization trick
 */</FONT></I>

<I><FONT COLOR="#B22222">// Hamming distances
</FONT></I><I><FONT COLOR="#B22222">/*
Given a list of n bit strings, each of length k,
calculate the minimum Hamming distance between two strings in the list.
The Hamming distance hamming(a,b) between two strings a and b of equal
length is the number of positions where the strings differ.

if k is small, we can optimize the code by storing the bit strings
as integers and calculating the Hamming distances using bit operations. In
particular, if k &lt;= 32, we can just store the strings as int values and use the
following function to calculate distances
*/</FONT></I>

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">hamming</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> a, <B><FONT COLOR="#228B22">int</FONT></B> b) {
    <B><FONT COLOR="#A020F0">return</FONT></B> __builtin_popcount(a^b);
}

<I><FONT COLOR="#B22222">// Count intersection of two sets (O(1))
</FONT></I><B><FONT COLOR="#0000FF">__builtin_popcount</FONT></B>(a &amp; b)

<I><FONT COLOR="#B22222">// For bigger set: Use unsigned long long. we can simulate a long binary number
</FONT></I><I><FONT COLOR="#B22222">//  with multiple unsigned long longs. The implementation isn't that bad but doing 
</FONT></I><I><FONT COLOR="#B22222">// binary shifts would be quite ugly. Turns out all of this can be done with bitsets easily.
</FONT></I><I><FONT COLOR="#B22222">// bitset&lt;365&gt; is a binary number with 365 bits available, and it supports most of binary operations.
</FONT></I>bitset&lt;MAX_D&gt; x[MAX_N];
<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">intersection</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i, <B><FONT COLOR="#228B22">int</FONT></B> j) {
	<B><FONT COLOR="#A020F0">return</FONT></B> (x[i] &amp; x[j]).count();
}
<I><FONT COLOR="#B22222">/*
construct a bitset from int or string bitset&lt;100&gt; a(17); bitset&lt;100&gt; b(&quot;1010&quot;);. 
You can even access particular bits with b[i]
*/</FONT></I>


<I><FONT COLOR="#B22222">// given a sequence of N &lt;= 10^7 numbers, each from interval [0,10^9]. How many 
</FONT></I><I><FONT COLOR="#B22222">// different values appear in the sequence? Don't use set or unordered_set because they quite slow.
</FONT></I><I><FONT COLOR="#B22222">// Create bitset&lt;1000000001&gt; visited, mark every given number visited[x] = 1, and print 
</FONT></I><I><FONT COLOR="#B22222">// visited.count(). The time complexity is O(N + MAX_X/32), space is O(MAX_X/32). This will use 
</FONT></I><I><FONT COLOR="#B22222">// 128 MB memory (one billion bits).</FONT></I></PRE>
<HR>
<A NAME="file43">
<H1>code/bitwise/trick.cc 43/70</H1>
[<A HREF="#top">top</A>][<A HREF="#file42">prev</A>][<A HREF="#file44">next</A>]
<PRE>
<I><FONT COLOR="#B22222">/**
 * Description: other bitwise trick
 */</FONT></I>

a + b = 2*(a &amp; b) + (a^b)
<I><FONT COLOR="#B22222">/*
Proof:
a^b is essentially just a + b in base 2 but we never carry over to the next bit. Recall a bit 
in a^b is 1 only if the bit in a is different from the bit in b, thus one of them must be a 1
. However, when we xor two 1 bits, we yield a 0, but we do not carry that 1 to the next bit. 
This is where a&amp;b comes in. a&amp;b is just the carry bits themselves, since a bit is 1 only if 
it's a 1 in both a and b, which is exactly what we need. We multiply this by 2 to shift all 
the bits to the left by one, so every value carries over to the next bit.
*/</FONT></I>

a ^ b = ~(a &amp; b) &amp; (a | b)

<I><FONT COLOR="#B22222">// addition
</FONT></I><I><FONT COLOR="#B22222">// If we perform addition without carrying, then we are simply performing the XOR operator. 
</FONT></I><I><FONT COLOR="#B22222">// Then, the bits that we carry over are those equivalent to 1 in both numbers: a&amp;b
</FONT></I><B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">add</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> a, <B><FONT COLOR="#228B22">int</FONT></B> b) {
	<B><FONT COLOR="#A020F0">while</FONT></B> (b &gt; 0) {
		<B><FONT COLOR="#228B22">int</FONT></B> carry = a &amp; b;
		a ^= b;
		b = carry &lt;&lt; 1;
	}
	<B><FONT COLOR="#A020F0">return</FONT></B> a;
}

<I><FONT COLOR="#B22222">// multiplication
</FONT></I><B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">prod</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> a, <B><FONT COLOR="#228B22">int</FONT></B> b) {
	<B><FONT COLOR="#228B22">int</FONT></B> c = 0;
	<B><FONT COLOR="#A020F0">while</FONT></B> (b &gt; 0) {
		<B><FONT COLOR="#A020F0">if</FONT></B> ((b &amp; 1) == 1) {
			c = add(c, a);  <I><FONT COLOR="#B22222">// Use the addition function we coded previously
</FONT></I>		}
		a &lt;&lt;= 1;
		b &gt;&gt;= 1;
	}
	<B><FONT COLOR="#A020F0">return</FONT></B> c;
}

<I><FONT COLOR="#B22222">// Biggest power of 2 that is a divisor of x
</FONT></I>1 &lt;&lt; __builtin_ctz(x)

<I><FONT COLOR="#B22222">// The smallest power of 2 that is not smaller than x but this is UB (undefined behavior) for x &lt;= 1 
</FONT></I><I><FONT COLOR="#B22222">// so you'll often need an if for x == 1
</FONT></I>1 &lt;&lt; (32 - __builtin_clz (x - 1))</PRE>
<HR>
<A NAME="file44">
<H1>code/STL/vector.cc 44/70</H1>
[<A HREF="#top">top</A>][<A HREF="#file43">prev</A>][<A HREF="#file45">next</A>]
<PRE>
<I><FONT COLOR="#B22222">/**
 * Description: Vector and iterator
 */</FONT></I>

vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; v; 
v.push_back(3); <I><FONT COLOR="#B22222">// [3] 
</FONT></I>v.push_back(2); <I><FONT COLOR="#B22222">// [3,2] 
</FONT></I>v.push_back(5); <I><FONT COLOR="#B22222">// [3,2,5]
</FONT></I>
vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; v = {2,4,2,5,1};
vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; a(8); <I><FONT COLOR="#B22222">// size 8, initial value 0 
</FONT></I>vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; b(8,2); <I><FONT COLOR="#B22222">// size 8, initial value 2
</FONT></I>
<B><FONT COLOR="#0000FF">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; v.size(); i++) { 
    cout &lt;&lt; v[i] &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;\n&quot;</FONT></B>;
}

<B><FONT COLOR="#0000FF">for</FONT></B> (<B><FONT COLOR="#228B22">auto</FONT></B> x : v) { 
    cout &lt;&lt; x &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;\n&quot;</FONT></B>;
}

vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; v = {2,4,2,5,1}; 
cout &lt;&lt; v.back() &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;\n&quot;</FONT></B>; <I><FONT COLOR="#B22222">// 1 
</FONT></I>v.pop_back();
cout &lt;&lt; v.back() &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;\n&quot;</FONT></B>; <I><FONT COLOR="#B22222">// 5
</FONT></I>
<I><FONT COLOR="#B22222">// An iterator is a variable that points to an element of a data structure. 
</FONT></I><I><FONT COLOR="#B22222">// The iterator begin points to the first element of a data structure, and the 
</FONT></I><I><FONT COLOR="#B22222">// iterator end points to the position after the last element. A range is a 
</FONT></I><I><FONT COLOR="#B22222">// sequence of consecutive elements in a data structure. The usual way to specify 
</FONT></I><I><FONT COLOR="#B22222">// a range is to give iterators to its first element and the position after its last element.
</FONT></I>
<B><FONT COLOR="#0000FF">sort</FONT></B>(v.begin(),v.end());
<B><FONT COLOR="#0000FF">reverse</FONT></B>(v.begin(),v.end());
<B><FONT COLOR="#0000FF">random_shuffle</FONT></B>(v.begin(),v.end());

cout &lt;&lt; *v.begin() &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;\n&quot;</FONT></B>;

vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; v = {2,3,3,5,7,8,8,8};
<I><FONT COLOR="#B22222">// If there is no such element, the functions return an iterator to the element after the last element in the range.
</FONT></I><B><FONT COLOR="#228B22">auto</FONT></B> a = lower_bound(v.begin(),v.end(),5); 
<B><FONT COLOR="#228B22">auto</FONT></B> b = upper_bound(v.begin(),v.end(),5); 
cout &lt;&lt; *a &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B> &lt;&lt; *b &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;\n&quot;</FONT></B>;

<I><FONT COLOR="#B22222">// creates a vector that contains the unique elements of the original vector in a sorted order:
</FONT></I><B><FONT COLOR="#0000FF">sort</FONT></B>(v.begin(),v.end());
v.erase(unique(v.begin(),v.end()),v.end());

<I><FONT COLOR="#B22222">// reverse iterator
</FONT></I><B><FONT COLOR="#0000FF">sort</FONT></B>(A.rbegin(), A.rend());

<I><FONT COLOR="#B22222">// insert val to position of iterator
</FONT></I>vi::iterator it;
it = v.begin() + 2;
v.insert(it, 9);
v.erase(it); <I><FONT COLOR="#B22222">// erase an element
</FONT></I>v.clear(); <I><FONT COLOR="#B22222">// delete all element
</FONT></I></PRE>
<HR>
<A NAME="file45">
<H1>code/STL/unorderedset.cc 45/70</H1>
[<A HREF="#top">top</A>][<A HREF="#file44">prev</A>][<A HREF="#file46">next</A>]
<PRE>
<I><FONT COLOR="#B22222">/**
 * Description: In unordered sets, elements are stored in an arbitrary order through hashing.
 * Insertions, deletions, and searches are all O(1) (with a high constant factor).
 * unordered set actually has worst case O(N). In any case, just default to using ordered sets.
 * Unordered sets work with primitive types, but require a custom hash function for structures/classes 
 * like vectors and pairs.
 */</FONT></I>

unordered_set&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; s;
s.insert(1);                 <I><FONT COLOR="#B22222">// {1}
</FONT></I>s.insert(4);                 <I><FONT COLOR="#B22222">// {1, 4}
</FONT></I>s.insert(2);                 <I><FONT COLOR="#B22222">// {1, 4, 2}
</FONT></I>s.insert(1);                 <I><FONT COLOR="#B22222">// does nothing because 1's already in the set
</FONT></I>cout &lt;&lt; s.count(1) &lt;&lt; endl;  <I><FONT COLOR="#B22222">// 1
</FONT></I>s.erase(1);                  <I><FONT COLOR="#B22222">// {2, 4}
</FONT></I>cout &lt;&lt; s.count(5) &lt;&lt; endl;  <I><FONT COLOR="#B22222">// 0
</FONT></I>s.erase(0);                  <I><FONT COLOR="#B22222">// does nothing because 0 wasn't in the set
</FONT></I></PRE>
<HR>
<A NAME="file46">
<H1>code/STL/tuple.cc 46/70</H1>
[<A HREF="#top">top</A>][<A HREF="#file45">prev</A>][<A HREF="#file47">next</A>]
<PRE>
<I><FONT COLOR="#B22222">/**
 * Description: Tuple
 */</FONT></I>

<I><FONT COLOR="#B22222">// tuple has built-in comparison function
</FONT></I><B><FONT COLOR="#228B22">typedef</FONT></B> tuple&lt;<B><FONT COLOR="#228B22">int</FONT></B>, string, string&gt; iss; <I><FONT COLOR="#B22222">// combine the 3 fields
</FONT></I><B><FONT COLOR="#228B22">auto</FONT></B> &amp;[ageA, lastA, firstA] = A; <I><FONT COLOR="#B22222">// decompose the tuple
</FONT></I>
vector&lt;iii&gt; EL(E);
<B><FONT COLOR="#0000FF">for</FONT></B> (<B><FONT COLOR="#228B22">auto</FONT></B> &amp;[w, u, v] : EL) <I><FONT COLOR="#B22222">// C++17 style
</FONT></I>
tuple &lt;<B><FONT COLOR="#228B22">char</FONT></B>, <B><FONT COLOR="#228B22">int</FONT></B>, <B><FONT COLOR="#228B22">float</FONT></B>&gt; geek;
geek = make_tuple(<B><FONT COLOR="#BC8F8F">'a'</FONT></B>, 10, 15.5);
cout &lt;&lt; get&lt;0&gt;(geek) &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B> &lt;&lt; get&lt;1&gt;(geek);
get&lt;0&gt;(geek) = <B><FONT COLOR="#BC8F8F">'b'</FONT></B>;
get&lt;2&gt;(geek) =  20.5;

<B><FONT COLOR="#228B22">int</FONT></B> i_val;
<B><FONT COLOR="#228B22">char</FONT></B> ch_val;
<B><FONT COLOR="#228B22">float</FONT></B> f_val;   
    
<I><FONT COLOR="#B22222">// Initializing tuple
</FONT></I>tuple&lt;<B><FONT COLOR="#228B22">int</FONT></B>,<B><FONT COLOR="#228B22">char</FONT></B>,<B><FONT COLOR="#228B22">float</FONT></B>&gt; tup1(20,<B><FONT COLOR="#BC8F8F">'g'</FONT></B>,17.5);

<I><FONT COLOR="#B22222">// Use of tie() without ignore
</FONT></I><B><FONT COLOR="#0000FF">tie</FONT></B>(i_val,ch_val,f_val) = tup1;
<I><FONT COLOR="#B22222">// ignores char value
</FONT></I><B><FONT COLOR="#0000FF">tie</FONT></B>(i_val,ignore,f_val) = tup1;
     </PRE>
<HR>
<A NAME="file47">
<H1>code/STL/string.cc 47/70</H1>
[<A HREF="#top">top</A>][<A HREF="#file46">prev</A>][<A HREF="#file48">next</A>]
<PRE>
<I><FONT COLOR="#B22222">/**
 * Description: String
 */</FONT></I>

<I><FONT COLOR="#B22222">/*
size()/length() : return size
empty() : check empty string
clear() : delete string
insert(pos, string) 
erase(pos, len)
find(string)
substr(pos, len)
append(string, pos, len)
*/</FONT></I>

<B><FONT COLOR="#228B22">int</FONT></B> result = isalpha(<B><FONT COLOR="#228B22">char</FONT></B> c)
<B><FONT COLOR="#228B22">int</FONT></B> result = isdigit(<B><FONT COLOR="#228B22">char</FONT></B> c)
<B><FONT COLOR="#228B22">int</FONT></B> result = islower(<B><FONT COLOR="#228B22">char</FONT></B> c)
<B><FONT COLOR="#228B22">int</FONT></B> result = isupper(<B><FONT COLOR="#228B22">char</FONT></B> c)

string <B><FONT COLOR="#0000FF">s</FONT></B>(<B><FONT COLOR="#BC8F8F">&quot;12&quot;</FONT></B>);
<I><FONT COLOR="#B22222">// atof(char *str)
</FONT></I><B><FONT COLOR="#228B22">int</FONT></B> number = atoi(s.c_str()); <I><FONT COLOR="#B22222">// turn string into integer. For double, use atof
</FONT></I>s = to_string(number);
<B><FONT COLOR="#228B22">char</FONT></B> c = toupper(s[2]); <I><FONT COLOR="#B22222">// tolower is the same</FONT></I></PRE>
<HR>
<A NAME="file48">
<H1>code/STL/stack.cc 48/70</H1>
[<A HREF="#top">top</A>][<A HREF="#file47">prev</A>][<A HREF="#file49">next</A>]
<PRE>
stack&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; s;
s.push(2); <I><FONT COLOR="#B22222">// [2]
</FONT></I>s.push(5); <I><FONT COLOR="#B22222">// [2,5]
</FONT></I>cout &lt;&lt; s.top() &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;\n&quot;</FONT></B>; <I><FONT COLOR="#B22222">// 5 
</FONT></I>s.pop(); <I><FONT COLOR="#B22222">// [2]
</FONT></I>cout &lt;&lt; s.top() &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;\n&quot;</FONT></B>; <I><FONT COLOR="#B22222">// 2
</FONT></I>
<I><FONT COLOR="#B22222">// Special Stack-based Problems
</FONT></I>
</PRE>
<HR>
<A NAME="file49">
<H1>code/STL/set.cc 49/70</H1>
[<A HREF="#top">top</A>][<A HREF="#file48">prev</A>][<A HREF="#file50">next</A>]
<PRE>
<I><FONT COLOR="#B22222">/**
 * Description: In sorted sets, the elements are sorted in order of element.
 * Insertions, deletions, and searches are all O(logN)
 * all the essential operations that unordered set has 
 */</FONT></I>

set&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; s;
s.insert(1);                        <I><FONT COLOR="#B22222">// [1]
</FONT></I>s.insert(14);                       <I><FONT COLOR="#B22222">// [1, 14]
</FONT></I>s.insert(9);                        <I><FONT COLOR="#B22222">// [1, 9, 14]
</FONT></I>s.insert(2);                        <I><FONT COLOR="#B22222">// [1, 2, 9, 14]
</FONT></I>
<I><FONT COLOR="#B22222">// lower_bound: returns an iterator to the least element greater than or equal to some element k.
</FONT></I><I><FONT COLOR="#B22222">// upper_bound: returns an iterator to the least element strictly greater than some element k.
</FONT></I><I><FONT COLOR="#B22222">// if the requested element does not exist, the return value is end().
</FONT></I>cout &lt;&lt; *s.upper_bound(7) &lt;&lt; <B><FONT COLOR="#BC8F8F">'\n'</FONT></B>;  <I><FONT COLOR="#B22222">// 9
</FONT></I>cout &lt;&lt; *s.upper_bound(9) &lt;&lt; <B><FONT COLOR="#BC8F8F">'\n'</FONT></B>;  <I><FONT COLOR="#B22222">// 14
</FONT></I>cout &lt;&lt; *s.lower_bound(5) &lt;&lt; <B><FONT COLOR="#BC8F8F">'\n'</FONT></B>;  <I><FONT COLOR="#B22222">// 9
</FONT></I>cout &lt;&lt; *s.lower_bound(9) &lt;&lt; <B><FONT COLOR="#BC8F8F">'\n'</FONT></B>;  <I><FONT COLOR="#B22222">// 9
</FONT></I>cout &lt;&lt; *s.begin() &lt;&lt; <B><FONT COLOR="#BC8F8F">'\n'</FONT></B>;         <I><FONT COLOR="#B22222">// 1
</FONT></I><B><FONT COLOR="#228B22">auto</FONT></B> it = s.end();
cout &lt;&lt; *(--it) &lt;&lt; <B><FONT COLOR="#BC8F8F">'\n'</FONT></B>;    <I><FONT COLOR="#B22222">// 14
</FONT></I>s.erase(s.upper_bound(6));  <I><FONT COLOR="#B22222">// [1, 2, 14]
</FONT></I>
<B><FONT COLOR="#0000FF">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> element : s) { cout &lt;&lt; element &lt;&lt; endl; }

<B><FONT COLOR="#228B22">auto</FONT></B> it = s.find(x); 
<B><FONT COLOR="#0000FF">if</FONT></B> (it == s.end()) {
    <I><FONT COLOR="#B22222">// x is not found
</FONT></I>}

<I><FONT COLOR="#B22222">// Real Runtime: Set > unordered_set > normal sorting</FONT></I></PRE>
<HR>
<A NAME="file50">
<H1>code/STL/queue.cc 50/70</H1>
[<A HREF="#top">top</A>][<A HREF="#file49">prev</A>][<A HREF="#file51">next</A>]
<PRE>
<I><FONT COLOR="#B22222">/**
 * Description: Queue
 */</FONT></I>

queue&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; q;
q.push(2); <I><FONT COLOR="#B22222">// [2]
</FONT></I>q.push(5); <I><FONT COLOR="#B22222">// [2,5]
</FONT></I>cout &lt;&lt; q.front() &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;\n&quot;</FONT></B>; <I><FONT COLOR="#B22222">// 2 
</FONT></I>q.pop(); <I><FONT COLOR="#B22222">// [5]
</FONT></I>cout &lt;&lt; q.back() &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;\n&quot;</FONT></B>; <I><FONT COLOR="#B22222">// 5</FONT></I></PRE>
<HR>
<A NAME="file51">
<H1>code/STL/pq.cc 51/70</H1>
[<A HREF="#top">top</A>][<A HREF="#file50">prev</A>][<A HREF="#file52">next</A>]
<PRE>
<I><FONT COLOR="#B22222">/**
 * Description: A priority queue (or heap) supports the following operations: insertion
 * of elements, deletion of the element considered highest priority, and retrieval
 * of the highest priority element, all in O(logN), retrieval takes O(1) time.
 */</FONT></I>

priority_queue&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; pq;
pq.push(7);                <I><FONT COLOR="#B22222">// [7]
</FONT></I>pq.push(2);                <I><FONT COLOR="#B22222">// [2, 7]
</FONT></I>pq.push(1);                <I><FONT COLOR="#B22222">// [1, 2, 7]
</FONT></I>pq.push(5);                <I><FONT COLOR="#B22222">// [1, 2, 5, 7]
</FONT></I>cout &lt;&lt; pq.top() &lt;&lt; endl;  <I><FONT COLOR="#B22222">// 7
</FONT></I>pq.pop();                  <I><FONT COLOR="#B22222">// [1, 2, 5]
</FONT></I>pq.pop();                  <I><FONT COLOR="#B22222">// [1, 2]
</FONT></I>pq.push(6);                <I><FONT COLOR="#B22222">// [1, 2, 6]
</FONT></I>
priority_queue&lt;<B><FONT COLOR="#228B22">int</FONT></B>,vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt;,greater&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt;&gt; q; <I><FONT COLOR="#B22222">// min heap
</FONT></I>
<I><FONT COLOR="#B22222">// Note: Priority queue is about five times faster than a multiset.</FONT></I></PRE>
<HR>
<A NAME="file52">
<H1>code/STL/orderStatistic.cc 52/70</H1>
[<A HREF="#top">top</A>][<A HREF="#file51">prev</A>][<A HREF="#file53">next</A>]
<PRE>
<I><FONT COLOR="#B22222">/**
 * Description: The one that we will use to solve the selection and ranking problems easily.
 * A data structure that supports all the operations as a set in C++ in addition to the following: 
 * 1. orderofkey(x): counts the number of elements in the set that are strictly less than x.
 * 2. findbyorder(k): similar to find, returns the iterator corresponding to the k-th lowest 
 * element in the set (0-indexed).
 */</FONT></I>


#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;bits/stdc++.h&gt;</FONT></B>
using namespace std;

#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;bits/extc++.h&gt;</FONT></B>                    // pbds
<I><FONT COLOR="#B22222">// #include &lt;ext/pb_ds/assoc_container.hpp&gt; // Common file
</FONT></I><I><FONT COLOR="#B22222">// #include &lt;ext/pb_ds/tree_policy.hpp&gt;     // Including tree_order_statistics_node_update
</FONT></I>
using namespace __gnu_pbds;
<I><FONT COLOR="#B22222">// for multiset, change less to less_equal
</FONT></I><B><FONT COLOR="#228B22">typedef</FONT></B> tree&lt;<B><FONT COLOR="#228B22">int</FONT></B>, null_type, less&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt;, rb_tree_tag, tree_order_statistics_node_update&gt; ordered_set;

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() { 
    ordered_set X;
    <I><FONT COLOR="#B22222">// X = {1, 2, 4, 8, 16}
</FONT></I>    
    <B><FONT COLOR="#A020F0">for</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i = 1; i &lt;= 16; i *= 2)
        X.insert(i); <I><FONT COLOR="#B22222">// O(n log n)
</FONT></I>    
    <I><FONT COLOR="#B22222">// O(log n) select
</FONT></I>    cout &lt;&lt; *X.find_by_order(0) &lt;&lt; endl; <I><FONT COLOR="#B22222">// 1 , 1-smallest = 1
</FONT></I>    cout &lt;&lt; *X.find_by_order(1) &lt;&lt; endl; <I><FONT COLOR="#B22222">// 2 
</FONT></I>    cout &lt;&lt; *X.find_by_order(2) &lt;&lt; endl; <I><FONT COLOR="#B22222">// 4
</FONT></I>    cout &lt;&lt; *X.find_by_order(4) &lt;&lt; endl; <I><FONT COLOR="#B22222">// 16, 5-smallest or largest = 16
</FONT></I>    cout &lt;&lt; (X.end()==X.find_by_order(6)) &lt;&lt; endl; <I><FONT COLOR="#B22222">// true
</FONT></I>
    <I><FONT COLOR="#B22222">// O(log n) rank
</FONT></I>    cout&lt;&lt;X.order_of_key(-5)&lt;&lt;endl;  <I><FONT COLOR="#B22222">// 0
</FONT></I>    cout&lt;&lt;X.order_of_key(1)&lt;&lt;endl;   <I><FONT COLOR="#B22222">// 0
</FONT></I>    cout&lt;&lt;X.order_of_key(3)&lt;&lt;endl;   <I><FONT COLOR="#B22222">// 2
</FONT></I>    cout&lt;&lt;X.order_of_key(4)&lt;&lt;endl;   <I><FONT COLOR="#B22222">// 2
</FONT></I>    cout&lt;&lt;X.order_of_key(400)&lt;&lt;endl; <I><FONT COLOR="#B22222">// 5
</FONT></I>}</PRE>
<HR>
<A NAME="file53">
<H1>code/STL/multiset.cc 53/70</H1>
[<A HREF="#top">top</A>][<A HREF="#file52">prev</A>][<A HREF="#file54">next</A>]
<PRE>
<I><FONT COLOR="#B22222">/**
 * Description: A multiset is a sorted set that allows multiple copies of the same element.
 */</FONT></I>


<I><FONT COLOR="#B22222">// Note that the functions count and erase have an additional O(k) factor
</FONT></I><I><FONT COLOR="#B22222">//  where k is the number of elements counted/removed.
</FONT></I><I><FONT COLOR="#B22222">// To remove a value once, use ms.erase(ms.find(val)).
</FONT></I><I><FONT COLOR="#B22222">// To remove all occurrences of a value, use ms.erase(val).
</FONT></I>

multiset&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; ms;
ms.insert(1);                  <I><FONT COLOR="#B22222">// [1]
</FONT></I>ms.insert(14);                 <I><FONT COLOR="#B22222">// [1, 14]
</FONT></I>ms.insert(9);                  <I><FONT COLOR="#B22222">// [1, 9, 14]
</FONT></I>ms.insert(2);                  <I><FONT COLOR="#B22222">// [1, 2, 9, 14]
</FONT></I>ms.insert(9);                  <I><FONT COLOR="#B22222">// [1, 2, 9, 9, 14]
</FONT></I>ms.insert(9);                  <I><FONT COLOR="#B22222">// [1, 2, 9, 9, 9, 14]
</FONT></I>cout &lt;&lt; ms.count(4) &lt;&lt; <B><FONT COLOR="#BC8F8F">'\n'</FONT></B>;   <I><FONT COLOR="#B22222">// 0
</FONT></I>cout &lt;&lt; ms.count(9) &lt;&lt; <B><FONT COLOR="#BC8F8F">'\n'</FONT></B>;   <I><FONT COLOR="#B22222">// 3
</FONT></I>cout &lt;&lt; ms.count(14) &lt;&lt; <B><FONT COLOR="#BC8F8F">'\n'</FONT></B>;  <I><FONT COLOR="#B22222">// 1
</FONT></I>ms.erase(ms.find(9));
cout &lt;&lt; ms.count(9) &lt;&lt; <B><FONT COLOR="#BC8F8F">'\n'</FONT></B>;  <I><FONT COLOR="#B22222">// 2
</FONT></I>ms.erase(9);
cout &lt;&lt; ms.count(9) &lt;&lt; <B><FONT COLOR="#BC8F8F">'\n'</FONT></B>;  <I><FONT COLOR="#B22222">// 0
</FONT></I></PRE>
<HR>
<A NAME="file54">
<H1>code/STL/map.cc 54/70</H1>
[<A HREF="#top">top</A>][<A HREF="#file53">prev</A>][<A HREF="#file55">next</A>]
<PRE>
<I><FONT COLOR="#B22222">/**
 * Description: A map is a set of entries, each consisting of a key and a value. 
 * In a map, all keys are required to be unique, but values can be repeated. 
 * Maps have three primary methods: add, retrive, remove.
 * In sorted maps, the pairs are sorted in order of key.
 * Insertions, deletions, and searches are all O(logN)
 * In unordered maps, the pairs aren't kept in sorted order 
 * and all insertions, deletions, and searches are all O(1)
 */</FONT></I>

map&lt;<B><FONT COLOR="#228B22">int</FONT></B>, <B><FONT COLOR="#228B22">int</FONT></B>&gt; m;
<I><FONT COLOR="#B22222">// unordered_map&lt;int, int&gt; m;
</FONT></I>m[1] = 5;                    <I><FONT COLOR="#B22222">// [(1, 5)]
</FONT></I>m[3] = 14;                   <I><FONT COLOR="#B22222">// [(1, 5); (3, 14)]
</FONT></I>m[2] = 7;                    <I><FONT COLOR="#B22222">// [(1, 5); (2, 7); (3, 14)]
</FONT></I>m[0] = -1;                   <I><FONT COLOR="#B22222">// [(0, -1); (1, 5); (2, 7); (3, 14)]
</FONT></I>m.erase(2);                  <I><FONT COLOR="#B22222">// [(0, -1); (1, 5); (3, 14)]
</FONT></I>cout &lt;&lt; m[1] &lt;&lt; endl;        <I><FONT COLOR="#B22222">// 5
</FONT></I>cout &lt;&lt; m.count(7) &lt;&lt; endl;  <I><FONT COLOR="#B22222">// 0
</FONT></I>cout &lt;&lt; m.count(1) &lt;&lt; endl;  <I><FONT COLOR="#B22222">// 1
</FONT></I>cout &lt;&lt; m[2] &lt;&lt; endl;        <I><FONT COLOR="#B22222">// 0
</FONT></I>
<B><FONT COLOR="#0000FF">for</FONT></B> (<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">auto</FONT></B> &amp;x : m) { cout &lt;&lt; x.first &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B> &lt;&lt; x.second &lt;&lt; endl; }

<B><FONT COLOR="#0000FF">for</FONT></B> (<B><FONT COLOR="#228B22">auto</FONT></B> &amp;x : m) {
	x.second = 1234;  <I><FONT COLOR="#B22222">// Change all values to 1234
</FONT></I>}

<I><FONT COLOR="#B22222">// Note: it is generally a bad idea to insert or remove elements of a map while iterating over it.
</FONT></I><I><FONT COLOR="#B22222">// One way to get around this is to just create a new map instead of removing from the old one.
</FONT></I><I><FONT COLOR="#B22222">// Another is to maintain a list of all the keys you want to erase and erase them after 
</FONT></I><I><FONT COLOR="#B22222">// the iteration finishes
</FONT></I>
map&lt;<B><FONT COLOR="#228B22">int</FONT></B>, <B><FONT COLOR="#228B22">int</FONT></B>&gt; m;
m[3] = 5;     <I><FONT COLOR="#B22222">// [(3, 5)]
</FONT></I>m[11] = 4;    <I><FONT COLOR="#B22222">// [(3, 5); (11, 4)]
</FONT></I>m[10] = 491;  <I><FONT COLOR="#B22222">// [(3, 5); (10, 491); (11, 4)]
</FONT></I>cout &lt;&lt; m.lower_bound(10)-&gt;first &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B> &lt;&lt; m.lower_bound(10)-&gt;second &lt;&lt; <B><FONT COLOR="#BC8F8F">'\n'</FONT></B>;  <I><FONT COLOR="#B22222">// 10 491
</FONT></I>cout &lt;&lt; m.upper_bound(10)-&gt;first &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B> &lt;&lt; m.upper_bound(10)-&gt;second &lt;&lt; <B><FONT COLOR="#BC8F8F">'\n'</FONT></B>;  <I><FONT COLOR="#B22222">// 11 4
</FONT></I>m.erase(11);   <I><FONT COLOR="#B22222">// [(3, 5); (10, 491)]
</FONT></I><B><FONT COLOR="#0000FF">if</FONT></B> (m.upper_bound(10) == m.end()) {
	cout &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;end&quot;</FONT></B> &lt;&lt; endl;  <I><FONT COLOR="#B22222">// Prints end
</FONT></I>}

<I><FONT COLOR="#B22222">// Note: unordered_map is about three times faster than map, an array is almost a hundred times faster.</FONT></I></PRE>
<HR>
<A NAME="file55">
<H1>code/STL/deque.cc 55/70</H1>
[<A HREF="#top">top</A>][<A HREF="#file54">prev</A>][<A HREF="#file56">next</A>]
<PRE>
<I><FONT COLOR="#B22222">/**
 * Description: Deque
 */</FONT></I>

deque&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; d; 
d.push_back(5); <I><FONT COLOR="#B22222">// [5] 
</FONT></I>d.push_back(2); <I><FONT COLOR="#B22222">// [5,2] 
</FONT></I>d.push_front(3); <I><FONT COLOR="#B22222">// [3,5,2] 
</FONT></I>d.pop_back(); <I><FONT COLOR="#B22222">// [3,5] 
</FONT></I>d.pop_front(); <I><FONT COLOR="#B22222">// [5]</FONT></I></PRE>
<HR>
<A NAME="file56">
<H1>code/STL/customComp.cc 56/70</H1>
[<A HREF="#top">top</A>][<A HREF="#file55">prev</A>][<A HREF="#file57">next</A>]
<PRE>
<I><FONT COLOR="#B22222">/**
 * Description: Comparators in sorting and ordered STL DS
 */</FONT></I>

<I><FONT COLOR="#B22222">// Essentially, the comparator determines whether object x belongs to the left 
</FONT></I><I><FONT COLOR="#B22222">// of object y in a sorted ordering.
</FONT></I>
<I><FONT COLOR="#B22222">// Method 1: Overloading the Less Than Operator. Only works for objects (not primitives)
</FONT></I><B><FONT COLOR="#228B22">struct</FONT></B> Edge {
	<B><FONT COLOR="#228B22">int</FONT></B> a, b, w;
	<B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#A020F0">operator</FONT></B>&lt;(<B><FONT COLOR="#228B22">const</FONT></B> Edge &amp;y) { <B><FONT COLOR="#A020F0">return</FONT></B> w &lt; y.w; }
};

<I><FONT COLOR="#B22222">// We can also overload the operator outside of the class:
</FONT></I><B><FONT COLOR="#228B22">struct</FONT></B> Edge {
	<B><FONT COLOR="#228B22">int</FONT></B> a, b, w;
};
<B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#A020F0">operator</FONT></B>&lt;(<B><FONT COLOR="#228B22">const</FONT></B> Edge &amp;x, <B><FONT COLOR="#228B22">const</FONT></B> Edge &amp;y) { <B><FONT COLOR="#A020F0">return</FONT></B> x.w &lt; y.w; }

<I><FONT COLOR="#B22222">// Method 2: Comparison Function. Works for both objects and primitives, 
</FONT></I><I><FONT COLOR="#B22222">// can declare many different comparators for the same object.
</FONT></I><B><FONT COLOR="#228B22">struct</FONT></B> Edge {
	<B><FONT COLOR="#228B22">int</FONT></B> a, b, w;
};

<I><FONT COLOR="#B22222">// If object x is less than object y , return true
</FONT></I><B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">cmp</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> Edge &amp;x, <B><FONT COLOR="#228B22">const</FONT></B> Edge &amp;y) { <B><FONT COLOR="#A020F0">return</FONT></B> x.w &lt; y.w; } 
<B><FONT COLOR="#0000FF">sort</FONT></B>(begin(v), end(v), cmp);

<B><FONT COLOR="#0000FF">sort</FONT></B>(begin(v), end(v), [](<B><FONT COLOR="#228B22">const</FONT></B> Edge &amp;x, <B><FONT COLOR="#228B22">const</FONT></B> Edge &amp;y) { <B><FONT COLOR="#A020F0">return</FONT></B> x.w &lt; y.w; }); <I><FONT COLOR="#B22222">// lambda expression
</FONT></I>

<I><FONT COLOR="#B22222">// C++ Sets with Custom Comparators
</FONT></I><I><FONT COLOR="#B22222">/*
make sure to include the second const or you'll get a compilation error.
[The second const] means you cannot modify member variables of the current object.
*/</FONT></I>
<B><FONT COLOR="#228B22">struct</FONT></B> Edge {
	<B><FONT COLOR="#228B22">int</FONT></B> a, b, w;
	<B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#A020F0">operator</FONT></B>&lt;(<B><FONT COLOR="#228B22">const</FONT></B> Edge &amp;y) <B><FONT COLOR="#228B22">const</FONT></B> { <B><FONT COLOR="#A020F0">return</FONT></B> w &lt; y.w; }
};

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {
	<B><FONT COLOR="#228B22">int</FONT></B> M = 4;
	set&lt;Edge&gt; v;
	<B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; M; ++i) {
		<B><FONT COLOR="#228B22">int</FONT></B> a, b, w;
		cin &gt;&gt; a &gt;&gt; b &gt;&gt; w;
		v.insert({a, b, w});
	}
	<B><FONT COLOR="#A020F0">for</FONT></B> (Edge e : v) cout &lt;&lt; e.a &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B> &lt;&lt; e.b &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B> &lt;&lt; e.w &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;\n&quot;</FONT></B>;
}

<I><FONT COLOR="#B22222">// With a function
</FONT></I><B><FONT COLOR="#228B22">struct</FONT></B> Edge {
	<B><FONT COLOR="#228B22">int</FONT></B> a, b, w;
};

<B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">cmp</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> Edge &amp;x, <B><FONT COLOR="#228B22">const</FONT></B> Edge &amp;y) { <B><FONT COLOR="#A020F0">return</FONT></B> x.w &lt; y.w; }

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {
	<B><FONT COLOR="#228B22">int</FONT></B> M = 4;
	set&lt;Edge, <B><FONT COLOR="#228B22">bool</FONT></B> (*)(<B><FONT COLOR="#228B22">const</FONT></B> Edge &amp;, <B><FONT COLOR="#228B22">const</FONT></B> Edge &amp;)&gt; v(cmp);
	<B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; M; ++i) {
		<B><FONT COLOR="#228B22">int</FONT></B> a, b, w;
		cin &gt;&gt; a &gt;&gt; b &gt;&gt; w;
		v.insert({a, b, w});
	}
	<B><FONT COLOR="#A020F0">for</FONT></B> (Edge e : v) cout &lt;&lt; e.a &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B> &lt;&lt; e.b &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B> &lt;&lt; e.w &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;\n&quot;</FONT></B>;
}
<I><FONT COLOR="#B22222">// You can also use the following syntax to declare set v using a function:
</FONT></I>set&lt;Edge,decltype(&amp;cmp)&gt; v(cmp);

<I><FONT COLOR="#B22222">// With lambda expression
</FONT></I><B><FONT COLOR="#228B22">auto</FONT></B> cmp = [](<B><FONT COLOR="#228B22">const</FONT></B> Edge &amp;x, <B><FONT COLOR="#228B22">const</FONT></B> Edge &amp;y) { <B><FONT COLOR="#A020F0">return</FONT></B> x.w &lt; y.w; };

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {
	<B><FONT COLOR="#228B22">int</FONT></B> M = 4;
	set&lt;Edge, <B><FONT COLOR="#228B22">bool</FONT></B> (*)(<B><FONT COLOR="#228B22">const</FONT></B> Edge &amp;, <B><FONT COLOR="#228B22">const</FONT></B> Edge &amp;)&gt; v(cmp);
	<B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; M; ++i) {
		<B><FONT COLOR="#228B22">int</FONT></B> a, b, w;
		cin &gt;&gt; a &gt;&gt; b &gt;&gt; w;
		v.insert({a, b, w});
	}
	<B><FONT COLOR="#A020F0">for</FONT></B> (Edge e : v) cout &lt;&lt; e.a &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B> &lt;&lt; e.b &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B> &lt;&lt; e.w &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;\n&quot;</FONT></B>;
}
<I><FONT COLOR="#B22222">// You can also use the following syntax to declare set v using a lambda
</FONT></I><I><FONT COLOR="#B22222">// even though decltype(cmp) is not actually equivalent to bool(*)(const Edge&amp;,const Edge&amp;). 
</FONT></I>set&lt;Edge,decltype(cmp)&gt; v(cmp);

<I><FONT COLOR="#B22222">// Functors. One functor can be used for multiple objects.
</FONT></I><B><FONT COLOR="#228B22">struct</FONT></B> Edge {
	<B><FONT COLOR="#228B22">int</FONT></B> a, b, w;
};

<B><FONT COLOR="#228B22">struct</FONT></B> cmp {
	<B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#A020F0">operator</FONT></B>()(<B><FONT COLOR="#228B22">const</FONT></B> Edge &amp;x, <B><FONT COLOR="#228B22">const</FONT></B> Edge &amp;y) <B><FONT COLOR="#228B22">const</FONT></B> { <B><FONT COLOR="#A020F0">return</FONT></B> x.w &lt; y.w; }
};

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {
	<B><FONT COLOR="#228B22">int</FONT></B> M = 4;
	set&lt;Edge, cmp&gt; v;
	<B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; M; ++i) {
		<B><FONT COLOR="#228B22">int</FONT></B> a, b, w;
		cin &gt;&gt; a &gt;&gt; b &gt;&gt; w;
		v.insert({a, b, w});
	}
	<B><FONT COLOR="#A020F0">for</FONT></B> (Edge e : v) cout &lt;&lt; e.a &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B> &lt;&lt; e.b &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B> &lt;&lt; e.w &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;\n&quot;</FONT></B>;
}

<I><FONT COLOR="#B22222">// We can also use cmp like a normal function by adding () after it.
</FONT></I><B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {
	<B><FONT COLOR="#228B22">int</FONT></B> M = 4;
	vector&lt;Edge&gt; v;
	<B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; M; ++i) {
		<B><FONT COLOR="#228B22">int</FONT></B> a, b, w;
		cin &gt;&gt; a &gt;&gt; b &gt;&gt; w;
		v.push_back({a, b, w});
	}
	sort(begin(v), end(v), cmp());
	<B><FONT COLOR="#A020F0">for</FONT></B> (Edge e : v) cout &lt;&lt; e.a &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B> &lt;&lt; e.b &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B> &lt;&lt; e.w &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;\n&quot;</FONT></B>;
}

<I><FONT COLOR="#B22222">// Built-in functor
</FONT></I><I><FONT COLOR="#B22222">// Overloading the less than operator (&lt;) automatically generates the functor less&lt;Edge&gt;. 
</FONT></I><I><FONT COLOR="#B22222">// Similarly, overloading (&gt;) automatically generates the functor greater&lt;Edge&gt;. 
</FONT></I><I><FONT COLOR="#B22222">// We can use this to store a set in reverse order.
</FONT></I>
<B><FONT COLOR="#228B22">struct</FONT></B> Edge {
	<B><FONT COLOR="#228B22">int</FONT></B> a, b, w;
	<B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#A020F0">operator</FONT></B>&gt;(<B><FONT COLOR="#228B22">const</FONT></B> Edge &amp;y) <B><FONT COLOR="#228B22">const</FONT></B> { <B><FONT COLOR="#A020F0">return</FONT></B> w &gt; y.w; }
};

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {
	<B><FONT COLOR="#228B22">int</FONT></B> M = 4;
	set&lt;Edge, greater&lt;Edge&gt;&gt; v;
	<B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; M; ++i) {
		<B><FONT COLOR="#228B22">int</FONT></B> a, b, w;
		cin &gt;&gt; a &gt;&gt; b &gt;&gt; w;
		v.insert({a, b, w});
	}
	<B><FONT COLOR="#A020F0">for</FONT></B> (Edge e : v) cout &lt;&lt; e.a &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B> &lt;&lt; e.b &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B> &lt;&lt; e.w &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;\n&quot;</FONT></B>;
}

<I><FONT COLOR="#B22222">/* Output:
2 3 10
1 2 9
1 3 7
2 4 3
*/</FONT></I>

<I><FONT COLOR="#B22222">// other Containers
</FONT></I>set&lt;<B><FONT COLOR="#228B22">int</FONT></B>, greater&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt;&gt; a;
map&lt;<B><FONT COLOR="#228B22">int</FONT></B>, string, greater&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt;&gt; b;
priority_queue&lt;<B><FONT COLOR="#228B22">int</FONT></B>, vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt;, greater&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt;&gt; c;</PRE>
<HR>
<A NAME="file57">
<H1>code/math/modint.cc 57/70</H1>
[<A HREF="#top">top</A>][<A HREF="#file56">prev</A>][<A HREF="#file58">next</A>]
<PRE>
<I><FONT COLOR="#B22222">/**
 * Description: templates that implement integer types that automatically 
 * wrap around when they exceed a certain modulus
 */</FONT></I>

<I><FONT COLOR="#B22222">/**
 * Description: Modular arithmetic. Assumes $MOD$ is prime.
 * Source: Benq Template
 * Verification: https://open.kattis.com/problems/modulararithmetic
 * Usage: mi a = MOD+5; inv(a); // 400000003
 */</FONT></I>

#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;bits/stdc++.h&gt;</FONT></B>
using namespace std;

<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> MOD = 1e9 + 7;

<B><FONT COLOR="#228B22">struct</FONT></B> mi {
	<B><FONT COLOR="#228B22">int</FONT></B> v;
	explicit <B><FONT COLOR="#A020F0">operator</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>() <B><FONT COLOR="#228B22">const</FONT></B> { <B><FONT COLOR="#A020F0">return</FONT></B> v; }
	mi() { v = 0; }
	mi(<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> _v) : v(_v % MOD) { v += (v &lt; 0) * MOD; }
};
mi &amp;<B><FONT COLOR="#A020F0">operator</FONT></B>+=(mi &amp;a, mi b) {
	<B><FONT COLOR="#A020F0">if</FONT></B> ((a.v += b.v) &gt;= MOD) a.v -= MOD;
	<B><FONT COLOR="#A020F0">return</FONT></B> a;
}
mi &amp;<B><FONT COLOR="#A020F0">operator</FONT></B>-=(mi &amp;a, mi b) {
	<B><FONT COLOR="#A020F0">if</FONT></B> ((a.v -= b.v) &lt; 0) a.v += MOD;
	<B><FONT COLOR="#A020F0">return</FONT></B> a;
}
mi <B><FONT COLOR="#A020F0">operator</FONT></B>+(mi a, mi b) { <B><FONT COLOR="#A020F0">return</FONT></B> a += b; }
mi <B><FONT COLOR="#A020F0">operator</FONT></B>-(mi a, mi b) { <B><FONT COLOR="#A020F0">return</FONT></B> a -= b; }
mi <B><FONT COLOR="#A020F0">operator</FONT></B>*(mi a, mi b) { <B><FONT COLOR="#A020F0">return</FONT></B> mi((<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B>)a.v * b.v); }
mi &amp;<B><FONT COLOR="#A020F0">operator</FONT></B>*=(mi &amp;a, mi b) { <B><FONT COLOR="#A020F0">return</FONT></B> a = a * b; }
mi <B><FONT COLOR="#0000FF">pow</FONT></B>(mi a, <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> p) {
	assert(p &gt;= 0);
	<B><FONT COLOR="#A020F0">return</FONT></B> p == 0 ? 1 : pow(a * a, p / 2) * (p &amp; 1 ? a : 1);
}
mi <B><FONT COLOR="#0000FF">inv</FONT></B>(mi a) {
	assert(a.v != 0);
	<B><FONT COLOR="#A020F0">return</FONT></B> pow(a, MOD - 2);
}
mi <B><FONT COLOR="#A020F0">operator</FONT></B>/(mi a, mi b) { <B><FONT COLOR="#A020F0">return</FONT></B> a * inv(b); }
<I><FONT COLOR="#B22222">// EndCodeSnip
</FONT></I>
<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {
	{
		<B><FONT COLOR="#228B22">int</FONT></B> a = 1e8, b = 1e8, c = 1e8;
		cout &lt;&lt; (<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B>)a * b % MOD * c % MOD &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;\n&quot;</FONT></B>;  <I><FONT COLOR="#B22222">// 49000000
</FONT></I>	}
	{
		mi a = 1e8, b = 1e8, c = 1e8;
		<I><FONT COLOR="#B22222">// cout &lt;&lt; a * b * c &lt;&lt; &quot;\n&quot;;  // Errors- we have to cast this an an int
</FONT></I>		cout &lt;&lt; (<B><FONT COLOR="#228B22">int</FONT></B>)(a * b * c) &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;\n&quot;</FONT></B>;  <I><FONT COLOR="#B22222">// 49000000
</FONT></I>	}
}

<I><FONT COLOR="#B22222">// Kactl template is another option </FONT></I></PRE>
<HR>
<A NAME="file58">
<H1>code/math/modinverse.cc 58/70</H1>
[<A HREF="#top">top</A>][<A HREF="#file57">prev</A>][<A HREF="#file59">next</A>]
<PRE>
<I><FONT COLOR="#B22222">/**
 * Description: Finding modular inverse
 * Time: O(logN) 
 */</FONT></I>

<I><FONT COLOR="#B22222">// Note: Nghich dao cua b theo modulo m ton tai khi b va m la nguyen to cung nhau
</FONT></I><I><FONT COLOR="#B22222">// O(log(m))
</FONT></I><I><FONT COLOR="#B22222">// If the modular inverse of the same number(s) is/are being used many times, 
</FONT></I><I><FONT COLOR="#B22222">// it is a good idea to precalculate it.
</FONT></I>
<I><FONT COLOR="#B22222">// Find mod inverse, using fermat little theorem
</FONT></I><B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">modInverse</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> b, <B><FONT COLOR="#228B22">int</FONT></B> m) {
    <B><FONT COLOR="#228B22">int</FONT></B> res = modpow(b, m - 2, m);
    <B><FONT COLOR="#A020F0">if</FONT></B> ((res * b) % m == 1) <B><FONT COLOR="#A020F0">return</FONT></B> res;
    <B><FONT COLOR="#A020F0">return</FONT></B> -1; <I><FONT COLOR="#B22222">// inverse doesnt exist
</FONT></I>}


<I><FONT COLOR="#B22222">// Using extended Euclidean algorithm
</FONT></I>vi <B><FONT COLOR="#0000FF">extendedEuclid</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> b, <B><FONT COLOR="#228B22">int</FONT></B> m) {
    vi res;
    <B><FONT COLOR="#228B22">int</FONT></B> q, r;
    <B><FONT COLOR="#228B22">int</FONT></B> x1 = 1, y1 = 0;
    <B><FONT COLOR="#228B22">int</FONT></B> x2 = 0, y2 = 1;
    <B><FONT COLOR="#228B22">int</FONT></B> x3 = 1, y3 = 0;
    <B><FONT COLOR="#A020F0">while</FONT></B> (m != 0) {
        q = b / m;
        r = b % m;
        x3 = x1 - q * x2;
        y3 = y1 - q * y2;
        x1 = x2, y1 = y2;
        x2 = x3, y2 = y3;
        b = m, m = r;
    }
    res.PB(b); res.PB(x1); res.PB(y1);
    <B><FONT COLOR="#A020F0">return</FONT></B> res;
}

<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">modInverse</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> b, <B><FONT COLOR="#228B22">int</FONT></B> m) {
    vi res = extendedEuclid(b, m);
    <B><FONT COLOR="#228B22">int</FONT></B> gcd = res[0];
    <B><FONT COLOR="#228B22">int</FONT></B> x = res[1];
    <B><FONT COLOR="#228B22">int</FONT></B> y = res[2];
    <B><FONT COLOR="#A020F0">if</FONT></B> (gcd != 1) cout &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;Inverse doesnt exist&quot;</FONT></B>;
    <B><FONT COLOR="#A020F0">else</FONT></B> cout &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;Mod inverse: &quot;</FONT></B> &lt;&lt; (x + m) % m &lt;&lt; endl;
}</PRE>
<HR>
<A NAME="file59">
<H1>code/math/modpow.cc 59/70</H1>
[<A HREF="#top">top</A>][<A HREF="#file58">prev</A>][<A HREF="#file60">next</A>]
<PRE>
<I><FONT COLOR="#B22222">/**
 * Description: Finding a^b%c
 * Time: O(logN) 
 */</FONT></I>

<I><FONT COLOR="#B22222">// Modular exponentiation
</FONT></I><I><FONT COLOR="#B22222">// efficiently calculate the value of x^n mod m. (CPH)
</FONT></I><B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">modpow</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> x, <B><FONT COLOR="#228B22">int</FONT></B> n, <B><FONT COLOR="#228B22">int</FONT></B> m) {
    <B><FONT COLOR="#A020F0">if</FONT></B> (n == 0) <B><FONT COLOR="#A020F0">return</FONT></B> 1%m;
    <B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> u = modpow(x,n/2,m);
    u = (u*u)%m;
    <B><FONT COLOR="#A020F0">if</FONT></B> (n%2 == 1) u = (u*x)%m;
    <B><FONT COLOR="#A020F0">return</FONT></B> u;
}

<I><FONT COLOR="#B22222">// Code 2:
</FONT></I>ll <B><FONT COLOR="#0000FF">exp</FONT></B>(ll x, ll n, ll m) {
	assert(n &gt;= 0);
	x %= m;  <I><FONT COLOR="#B22222">// note: m * m must be less than 2^63 to avoid ll overflow
</FONT></I>	ll res = 1;
	<B><FONT COLOR="#A020F0">while</FONT></B> (n &gt; 0) {
		<B><FONT COLOR="#A020F0">if</FONT></B> (n % 2 == 1) { res = (res * x) % m; }
		x = (x * x) % m;
		n /= 2;
	}
	<B><FONT COLOR="#A020F0">return</FONT></B> res;
}

</PRE>
<HR>
<A NAME="file60">
<H1>code/math/prime.cc 60/70</H1>
[<A HREF="#top">top</A>][<A HREF="#file59">prev</A>][<A HREF="#file61">next</A>]
<PRE>
<B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">isPrime</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> n) {
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 2; i*i &lt;= n; i++)
        <B><FONT COLOR="#A020F0">if</FONT></B> (n % i == 0) <B><FONT COLOR="#A020F0">return</FONT></B> false;
    <B><FONT COLOR="#A020F0">return</FONT></B> n &gt; 1;
}

<I><FONT COLOR="#B22222">// Sieve of Eratosthenes, Find all prime &lt;= N
</FONT></I>vi <B><FONT COLOR="#0000FF">sieve</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> n) { <I><FONT COLOR="#B22222">// O(nlogn)
</FONT></I>    vector&lt;<B><FONT COLOR="#228B22">bool</FONT></B>&gt; mark;
    vi primes;
    mark.resize(n + 1, true);
    mark[0] = mark[1] = false;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 2; i * i &lt;= n; i++) {
        <B><FONT COLOR="#A020F0">if</FONT></B> (mark[i]) {
            <I><FONT COLOR="#B22222">// Mark all the multiples of i as composite numbers
</FONT></I>            <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = i * i; j &lt;= n; j += i) {
                mark[j] = false;
            }
        }
    }

    <I><FONT COLOR="#B22222">// return all primes &lt;= n
</FONT></I>    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 2; i &lt;= n; i++) {
        <B><FONT COLOR="#A020F0">if</FONT></B> (mark[i]) primes.push_back(i);
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> primes;
}

<I><FONT COLOR="#B22222">// Segmented Sieve: Find all prime in [left, right]
</FONT></I><I><FONT COLOR="#B22222">// 1 &lt;= left &lt;= right &lt;= 10^12 and right-left &lt;= 10^6
</FONT></I>vi <B><FONT COLOR="#0000FF">segmentedSieve</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> left, <B><FONT COLOR="#228B22">int</FONT></B> right, vi primes) {
    <B><FONT COLOR="#A020F0">if</FONT></B> (left == 1) left++;
    vector&lt;<B><FONT COLOR="#228B22">bool</FONT></B>&gt; mark;
    mark.resize(right - left + 1, true);

    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; sz(primes) &amp;&amp; primes[i] &lt;= sqrt(right); i++) {
        <B><FONT COLOR="#228B22">int</FONT></B> base = (left / primes[i]) * primes[i];
        <B><FONT COLOR="#A020F0">if</FONT></B> (base &lt; left) base += primes[i];
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = base; j &lt;= right; j += primes[i]) {
            <B><FONT COLOR="#A020F0">if</FONT></B> (j != primes[i]) mark[j - left] = false;
        }
    }

    vi res;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = left; i &lt;= right; i++) {
        <B><FONT COLOR="#A020F0">if</FONT></B> (mark[i - left]) res.push_back(i);
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> res;
}

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">main</FONT></B>() {
    <B><FONT COLOR="#228B22">int</FONT></B> left = 11, right = 34;
    vi primes = sieve(sqrt(right));
    vi res = segmentedSieve(left, right, primes);
}


<I><FONT COLOR="#B22222">// Prime Factorization. Factorization of 252 = {2,2,3,3,7}
</FONT></I>vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; factor(<B><FONT COLOR="#228B22">int</FONT></B> n) { <I><FONT COLOR="#B22222">// O(sqrt(N))
</FONT></I>	vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; ret;
	<B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 2; i * i &lt;= n; i++) {
		<B><FONT COLOR="#A020F0">while</FONT></B> (n % i == 0) {
			ret.push_back(i);
			n /= i;
		}
	}
	<B><FONT COLOR="#A020F0">if</FONT></B> (n &gt; 1) { ret.push_back(n); }
	<B><FONT COLOR="#A020F0">return</FONT></B> ret;
}

<I><FONT COLOR="#B22222">// Prime factorization using sieve: O(logN)
</FONT></I><I><FONT COLOR="#B22222">// x can have O(logx) distinct prime factors
</FONT></I><B><FONT COLOR="#228B22">int</FONT></B> minPrime[n + 1];
<B><FONT COLOR="#0000FF">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 2; i * i &lt;= n; ++i) {
    <B><FONT COLOR="#A020F0">if</FONT></B> (minPrime[i] == 0) { <I><FONT COLOR="#B22222">//if i is prime
</FONT></I>        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = i * i; j &lt;= n; j += i) {
            <B><FONT COLOR="#A020F0">if</FONT></B> (minPrime[j] == 0) {
                minPrime[j] = i;
            }
        }
    }
}
<B><FONT COLOR="#0000FF">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 2; i &lt;= n; ++i) {
    <B><FONT COLOR="#A020F0">if</FONT></B> (minPrime[i] == 0) {
        minPrime[i] = i;
    }
}

vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; factorize(<B><FONT COLOR="#228B22">int</FONT></B> n) { 
    vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; res;
    <B><FONT COLOR="#A020F0">while</FONT></B> (n != 1) {
        res.push_back(minPrime[n]);
        n /= minPrime[n];
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> res;
}</PRE>
<HR>
<A NAME="file61">
<H1>code/math/gcdlcm.cc 61/70</H1>
[<A HREF="#top">top</A>][<A HREF="#file60">prev</A>][<A HREF="#file62">next</A>]
<PRE>
<I><FONT COLOR="#B22222">/**
 * Description: GCD and LCM
 * Time: O(logab) for gcd 
 */</FONT></I>

<I><FONT COLOR="#B22222">// For C++14, you can use the built-in __gcd(a,b).
</FONT></I><I><FONT COLOR="#B22222">// In C++17, there exists std::gcd and std::lcm in the &lt;numeric&gt; header
</FONT></I><I><FONT COLOR="#B22222">// Note: lcm(a, b) = ab/gcd(a, b)
</FONT></I>
<I><FONT COLOR="#B22222">// Also, these two functions are associative, meaning that
</FONT></I><I><FONT COLOR="#B22222">// if we want to take the GCD or LCM of more than two elements, we can do so two at
</FONT></I><I><FONT COLOR="#B22222">// a time, in any order. For example,
</FONT></I>
<I><FONT COLOR="#B22222">// gcd(a1, a2, a3, a4) = gcd(a1, gcd(a2, gcd(a3, a4)))
</FONT></I></PRE>
<HR>
<A NAME="file62">
<H1>code/math/eulerphi.cc 62/70</H1>
[<A HREF="#top">top</A>][<A HREF="#file61">prev</A>][<A HREF="#file63">next</A>]
<PRE>
<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">phi</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> n) { 
    <B><FONT COLOR="#228B22">int</FONT></B> res = n;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 2; i * i &lt;= n; ++i) {
        <B><FONT COLOR="#A020F0">if</FONT></B> (n % i == 0) {
            <B><FONT COLOR="#A020F0">while</FONT></B> (n % i == 0) {
                n /= i;
            }
            res = res / i * (i - 1);
        }
    }
    <B><FONT COLOR="#A020F0">if</FONT></B> (n &gt; 1) {
        res = res / n * (n - 1);
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> res;
}</PRE>
<HR>
<A NAME="file63">
<H1>code/combinatorics/bc.cc 63/70</H1>
[<A HREF="#top">top</A>][<A HREF="#file62">prev</A>][<A HREF="#file64">next</A>]
<PRE>
<I><FONT COLOR="#B22222">/**
 * Description: Binomial coefficient
 */</FONT></I>

<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> MAXN = 1e6;
<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> MOD = 1e9 + 7;

ll fac[MAXN + 1];
ll inv[MAXN + 1];

<I><FONT COLOR="#B22222">/** Computes x^n modulo m in O(log mod) time. */</FONT></I>
ll <B><FONT COLOR="#0000FF">exp</FONT></B>(ll x, ll n, ll m) {
	x %= m;
	ll res = 1;
	<B><FONT COLOR="#A020F0">while</FONT></B> (n &gt; 0) {
		<B><FONT COLOR="#A020F0">if</FONT></B> (n % 2 == 1) { res = res * x % m; }
		x = x * x % m;
		n /= 2;
	}
	<B><FONT COLOR="#A020F0">return</FONT></B> res;
}

<I><FONT COLOR="#B22222">/** Precomputes n! from 0 to MAXN. */</FONT></I>
<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">factorial</FONT></B>() {
	fac[0] = 1;
	<B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 1; i &lt;= MAXN; i++) { fac[i] = fac[i - 1] * i % MOD; }
}

<I><FONT COLOR="#B22222">/**
 * Precomputes all modular inverse factorials
 * from 0 to MAXN in O(n + log mod) time
 */</FONT></I>
<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">inverses</FONT></B>() {
	inv[MAXN] = exp(fac[MAXN], MOD - 2, MOD);
	<B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = MAXN; i &gt;= 1; i--) { inv[i - 1] = inv[i] * i % MOD; }
}

<I><FONT COLOR="#B22222">/** Computes nCr mod p */</FONT></I>
ll <B><FONT COLOR="#0000FF">choose</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> n, <B><FONT COLOR="#228B22">int</FONT></B> r) { <B><FONT COLOR="#A020F0">return</FONT></B> fac[n] * inv[r] % MOD * inv[n - r] % MOD; }


<B><FONT COLOR="#0000FF">factorial</FONT></B>();
<B><FONT COLOR="#0000FF">inverses</FONT></B>();
<B><FONT COLOR="#0000FF">choose</FONT></B>(a, b);</PRE>
<HR>
<A NAME="file64">
<H1>code/other/cc.cc 64/70</H1>
[<A HREF="#top">top</A>][<A HREF="#file63">prev</A>][<A HREF="#file65">next</A>]
<PRE>
<I><FONT COLOR="#B22222">/**
 * Description: coordinate Compression
 */</FONT></I>

<I><FONT COLOR="#B22222">// Coordinate compression describes the process of mapping each value in a list to 
</FONT></I><I><FONT COLOR="#B22222">// its index if that list was sorted. (labelling coordinate with compressed values)
</FONT></I><I><FONT COLOR="#B22222">// When we have values from a large range, but we only care about their relative order 
</FONT></I><I><FONT COLOR="#B22222">// (for example, if we have to know if one value is above another), coordinate compression 
</FONT></I><I><FONT COLOR="#B22222">// is a simple way to help with implementation.
</FONT></I>
<B><FONT COLOR="#228B22">typedef</FONT></B> pair&lt;<B><FONT COLOR="#228B22">int</FONT></B>, <B><FONT COLOR="#228B22">int</FONT></B>&gt; Point;
<B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">ycomp</FONT></B>(Point p, Point q) { <B><FONT COLOR="#A020F0">return</FONT></B> p.second &lt; q.second; }

<I><FONT COLOR="#B22222">// Perform compression on a set of points =&gt; Can be used as array indices
</FONT></I><B><FONT COLOR="#0000FF">sort</FONT></B>(P, P + N);
<B><FONT COLOR="#0000FF">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; N; i++) P[i].first = i + 1;
<B><FONT COLOR="#0000FF">sort</FONT></B>(P, P + N, ycomp);
<B><FONT COLOR="#0000FF">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; N; i++) P[i].second = i + 1;

<I><FONT COLOR="#B22222">// coordinate compression sometimes will also require remembering values in addition 
</FONT></I><I><FONT COLOR="#B22222">// to compressing them (as opposed to just replacing the original values)</FONT></I></PRE>
<HR>
<A NAME="file65">
<H1>code/other/backtracking.cc 65/70</H1>
[<A HREF="#top">top</A>][<A HREF="#file64">prev</A>][<A HREF="#file66">next</A>]
<PRE>
<I><FONT COLOR="#B22222">/**
 * Description: Backtracking model
 */</FONT></I>

<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> maxn = 33;
<B><FONT COLOR="#228B22">int</FONT></B> x[maxn];
<B><FONT COLOR="#228B22">int</FONT></B> n;

<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">printRes</FONT></B>(){
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 1; i &lt;= n; i++){
        cout &lt;&lt; x[i];
    }
    cout &lt;&lt; endl;
}

<I><FONT COLOR="#B22222">// find all binary string of length N
</FONT></I><B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">backtrack</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i){
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 0; j &lt;= 1; j++){ <I><FONT COLOR="#B22222">// all values can be assigned to x[i] 
</FONT></I>        x[i] = j; <I><FONT COLOR="#B22222">// try x[i] = j
</FONT></I>        <B><FONT COLOR="#A020F0">if</FONT></B> (i == n) printRes(); <I><FONT COLOR="#B22222">// tim thay 1 cau hinh
</FONT></I>        <B><FONT COLOR="#A020F0">else</FONT></B> backtrack(i + 1); <I><FONT COLOR="#B22222">// recursively try values for x[i + 1]
</FONT></I>    }
}

<I><FONT COLOR="#B22222">// backtrack(1)
</FONT></I>
<I><FONT COLOR="#B22222">// Liet ke cac tap con k phan tu
</FONT></I><B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">backtrack</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i){
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = x[i - 1] + 1; j &lt;= n - k + i; j++){
        x[i] = j;
        <B><FONT COLOR="#A020F0">if</FONT></B> (i == k) printRes();
        <B><FONT COLOR="#A020F0">else</FONT></B> backtrack(i + 1);
    }
}

<I><FONT COLOR="#B22222">// Liet ke cac chinh hop ko lap chap k
</FONT></I><B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">backtrack</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> i){
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 1; j &lt;= n ;j++){
        <B><FONT COLOR="#A020F0">if</FONT></B> (c[j]){
            x[i] = j;
            <B><FONT COLOR="#A020F0">if</FONT></B> (i == k) printRes();
            <B><FONT COLOR="#A020F0">else</FONT></B> {
                c[j] = false;
                backtrack(i + 1);
                c[j] = true;
            }
        }
    }
}

</PRE>
<HR>
<A NAME="file66">
<H1>code/dp/coinexchange.cc 66/70</H1>
[<A HREF="#top">top</A>][<A HREF="#file65">prev</A>][<A HREF="#file67">next</A>]
<PRE>
<I><FONT COLOR="#B22222">// Returns number of ways we can exchange k using set of coins {{{
</FONT></I><B><FONT COLOR="#228B22">template</FONT></B>&lt;typename T&gt;
T coin_exchange(<B><FONT COLOR="#228B22">int</FONT></B> k, std::vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; coins) {
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::vector&lt;T&gt; f(k + 1);
    f[0] = 1;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> coin : coins) {
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = coin; i &lt;= k; ++i) {
            f[i] += f[i-coin];
        }
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> f.back();
}
<I><FONT COLOR="#B22222">// }}}</FONT></I></PRE>
<HR>
<A NAME="file67">
<H1>code/dp/editdistance.cc 67/70</H1>
[<A HREF="#top">top</A>][<A HREF="#file66">prev</A>][<A HREF="#file68">next</A>]
<PRE>
<I><FONT COLOR="#B22222">// Minimum number of operations to transform string a =&gt; string b
</FONT></I><I><FONT COLOR="#B22222">// In one operation, we can either modify 1 character, delete 1 character or
</FONT></I><I><FONT COLOR="#B22222">// insert 1 character (insert is not needed in this case)
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// Edit distance {{{
</FONT></I><B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">edit_distance</FONT></B>(std::string a, std::string b) {
    <B><FONT COLOR="#228B22">int</FONT></B> la = a.size();
    <B><FONT COLOR="#228B22">int</FONT></B> lb = b.size();
    a = <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B> + a + <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>;
    b = <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B> + b + <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>;

    <B><FONT COLOR="#5F9EA0">std</FONT></B>::vector&lt;std::vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt;&gt; f(la + 1, std::vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; (lb + 1, la + lb));

    <I><FONT COLOR="#B22222">// corner cases
</FONT></I>    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 0; j &lt;= lb; ++j) f[0][j] = j;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt;= la; ++i) f[i][0] = i;

    <I><FONT COLOR="#B22222">// DP
</FONT></I>    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 1; i &lt;= la; ++i) {
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = 1; j &lt;= lb; ++j) {
            <B><FONT COLOR="#A020F0">if</FONT></B> (a[i] == b[j]) f[i][j] = f[i-1][j-1];
            <B><FONT COLOR="#A020F0">else</FONT></B> f[i][j] = 1 + std::min({
                    f[i-1][j-1],  <I><FONT COLOR="#B22222">// modify
</FONT></I>                    f[i][j-1],    <I><FONT COLOR="#B22222">// remove b[j]
</FONT></I>                    f[i-1][j],    <I><FONT COLOR="#B22222">// remove a[i]
</FONT></I>                    });
        }
    }

    <B><FONT COLOR="#A020F0">return</FONT></B> f.back().back();
}
<I><FONT COLOR="#B22222">// }}}</FONT></I></PRE>
<HR>
<A NAME="file68">
<H1>code/dp/knapsack.cc 68/70</H1>
[<A HREF="#top">top</A>][<A HREF="#file67">prev</A>][<A HREF="#file69">next</A>]
<PRE>
<I><FONT COLOR="#B22222">// Knapsack 01 {{{
</FONT></I><I><FONT COLOR="#B22222">// Select subset of items, such that sum(weights) &lt;= capacity
</FONT></I><I><FONT COLOR="#B22222">// and sum(values) is maximum
</FONT></I><B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">knapsack01</FONT></B>(
        <B><FONT COLOR="#228B22">int</FONT></B> capacity,
        <B><FONT COLOR="#228B22">const</FONT></B> std::vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt;&amp; weights,
        <B><FONT COLOR="#228B22">const</FONT></B> std::vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt;&amp; values) {
    <B><FONT COLOR="#228B22">int</FONT></B> n = weights.size();
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; f(capacity + 1, 0);
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; n; ++i) {
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = capacity; j &gt;= weights[i]; --j) {
            f[j] = max(f[j], f[j-weights[i]] + values[i]);
        }
    }

    <B><FONT COLOR="#A020F0">return</FONT></B> *max_element(f.begin(), f.end());
}
<I><FONT COLOR="#B22222">// }}}
</FONT></I><I><FONT COLOR="#B22222">// Knapsack unbounded {{{
</FONT></I><I><FONT COLOR="#B22222">// Select subset of items, such that sum(weights) &lt;= capacity
</FONT></I><I><FONT COLOR="#B22222">// and sum(values) is maximum
</FONT></I><I><FONT COLOR="#B22222">// An item can be selected unlimited number of times
</FONT></I><B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">knapsack_unbounded</FONT></B>(
        <B><FONT COLOR="#228B22">int</FONT></B> capacity,
        <B><FONT COLOR="#228B22">const</FONT></B> std::vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt;&amp; weights,
        <B><FONT COLOR="#228B22">const</FONT></B> std::vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt;&amp; values) {
    <B><FONT COLOR="#228B22">int</FONT></B> n = weights.size();
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::vector&lt;<B><FONT COLOR="#228B22">int</FONT></B>&gt; f(capacity + 1, 0);
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; n; ++i) {
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> j = weights[i]; j &lt;= capacity; ++j) {
            f[j] = max(f[j], f[j-weights[i]] + values[i]);
        }
    }

    <B><FONT COLOR="#A020F0">return</FONT></B> *max_element(f.begin(), f.end());
}
<I><FONT COLOR="#B22222">// }}}</FONT></I></PRE>
<HR>
<A NAME="file69">
<H1>code/dp/lis.cc 69/70</H1>
[<A HREF="#top">top</A>][<A HREF="#file68">prev</A>][<A HREF="#file70">next</A>]
<PRE>
<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">find_lis</FONT></B>(vi &amp;a) {
    vi dp;
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">int</FONT></B> i : a) {
        <B><FONT COLOR="#228B22">int</FONT></B> pos = lower_bound(dp.begin(), dp.end(), i) - dp.begin();
        <B><FONT COLOR="#A020F0">if</FONT></B> (pos == sz(dp)) dp.push_back(i);
        <B><FONT COLOR="#A020F0">else</FONT></B> {
            dp[pos] = i;
        }
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> dp.size();
}</PRE>
<HR>
<A NAME="file70">
<H1>code/dandq/binsearch.cc 70/70</H1>
[<A HREF="#top">top</A>][<A HREF="#file69">prev</A>][next]
<PRE>
<I><FONT COLOR="#B22222">// find target in an monotonic array
</FONT></I><B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">binary_search</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> A[], <B><FONT COLOR="#228B22">int</FONT></B> sizeA, <B><FONT COLOR="#228B22">int</FONT></B> target) {
    <B><FONT COLOR="#228B22">int</FONT></B> lo = 1, hi = sizeA;
    <B><FONT COLOR="#A020F0">while</FONT></B> (lo &lt;= hi) {
        <B><FONT COLOR="#228B22">int</FONT></B> mid = lo + (hi - lo)/2;
        <B><FONT COLOR="#A020F0">if</FONT></B> (A[mid] == target)
            <B><FONT COLOR="#A020F0">return</FONT></B> mid;       	
        <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (A[mid] &lt; target)
            lo = mid+1;
        <B><FONT COLOR="#A020F0">else</FONT></B>
            hi = mid-1;
    }
    <I><FONT COLOR="#B22222">// target not found in A
</FONT></I>    <B><FONT COLOR="#A020F0">return</FONT></B> -1;
}  

<I><FONT COLOR="#B22222">// Find smallest x such that P(x) = true
</FONT></I><I><FONT COLOR="#B22222">// If P(S) is of the form true-false, just reverse P(x)
</FONT></I><B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">P</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> x) {
    <I><FONT COLOR="#B22222">// Ham danh gia x
</FONT></I>    <B><FONT COLOR="#A020F0">return</FONT></B> true;  
}

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">binary_search</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> lo, <B><FONT COLOR="#228B22">int</FONT></B> hi) {
    <B><FONT COLOR="#A020F0">while</FONT></B> (lo &lt; hi) {
        <B><FONT COLOR="#228B22">int</FONT></B> mid = lo + (hi-lo)/2;
        <B><FONT COLOR="#A020F0">if</FONT></B> (P(mid) == true)
            hi = mid;
        <B><FONT COLOR="#A020F0">else</FONT></B>
            lo = mid+1;
    }
  	
    <B><FONT COLOR="#A020F0">if</FONT></B> (P(lo) == false)
        <B><FONT COLOR="#A020F0">return</FONT></B> -1; <I><FONT COLOR="#B22222">// P(x) = false for all x in S, no solution
</FONT></I>  	
   <B><FONT COLOR="#A020F0">return</FONT></B> lo; <I><FONT COLOR="#B22222">// lo is smallest x that P(x) = true
</FONT></I>}

<I><FONT COLOR="#B22222">// Find biggest x such that P(x) = false
</FONT></I><B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">binary_search</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> lo, <B><FONT COLOR="#228B22">int</FONT></B> hi) {
    <B><FONT COLOR="#A020F0">while</FONT></B> (lo &lt; hi) {
        <B><FONT COLOR="#228B22">int</FONT></B> mid = lo + (hi-lo+1)/2;
        <B><FONT COLOR="#A020F0">if</FONT></B> (P(mid) == true)
            hi = mid - 1;
        <B><FONT COLOR="#A020F0">else</FONT></B>
            lo = mid;
    }
  	
    <B><FONT COLOR="#A020F0">if</FONT></B> (P(lo) == true)
        <B><FONT COLOR="#A020F0">return</FONT></B> -1; <I><FONT COLOR="#B22222">// P(x) = true for all x in S, no solution
</FONT></I>  	
   <B><FONT COLOR="#A020F0">return</FONT></B> lo; <I><FONT COLOR="#B22222">// lo is largest x that P(x) = false
</FONT></I>}

<I><FONT COLOR="#B22222">// Binary search on real range
</FONT></I><B><FONT COLOR="#228B22">bool</FONT></B> <B><FONT COLOR="#0000FF">isTerminated</FONT></B>(<B><FONT COLOR="#228B22">double</FONT></B> lo, <B><FONT COLOR="#228B22">double</FONT></B> hi) {
    <I><FONT COLOR="#B22222">// return result of check
</FONT></I>    <I><FONT COLOR="#B22222">// Do lo and hi satisfy stop condition?
</FONT></I>}

<B><FONT COLOR="#228B22">double</FONT></B> <B><FONT COLOR="#0000FF">binary_search</FONT></B>(<B><FONT COLOR="#228B22">double</FONT></B> lo, <B><FONT COLOR="#228B22">double</FONT></B> hi) {
    <B><FONT COLOR="#A020F0">while</FONT></B> (isTerminated(lo, hi) == false) {
        <B><FONT COLOR="#228B22">double</FONT></B> mid = lo + (hi-lo)/2;
        <B><FONT COLOR="#A020F0">if</FONT></B> (P(mid) == true)
            hi = mid;
        <B><FONT COLOR="#A020F0">else</FONT></B>
            lo = mid;
    }
    <I><FONT COLOR="#B22222">// Approximate mean of lo and hi
</FONT></I>    <I><FONT COLOR="#B22222">// boundary between false and true
</FONT></I>    <B><FONT COLOR="#A020F0">return</FONT></B> lo + (hi-lo)/2; 
}

<I><FONT COLOR="#B22222">// Binary search implementation with open range
</FONT></I><I><FONT COLOR="#B22222">// hi must be greater than actual search range by 1
</FONT></I><I><FONT COLOR="#B22222">// In the case we want to find the last false then the open range will be (lo, hi] 
</FONT></I><I><FONT COLOR="#B22222">// and search returns lo if every values in range are true
</FONT></I><B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">binary_search</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> lo, <B><FONT COLOR="#228B22">int</FONT></B> hi) {
    <B><FONT COLOR="#A020F0">while</FONT></B> (lo &lt; hi) {
        <B><FONT COLOR="#228B22">int</FONT></B> mid = lo + (hi-lo)/2;
        <B><FONT COLOR="#A020F0">if</FONT></B> (P(mid) == true)
            hi = mid;
        <B><FONT COLOR="#A020F0">else</FONT></B>
            lo = mid+1;
    }
  	
   <B><FONT COLOR="#A020F0">return</FONT></B> lo; <I><FONT COLOR="#B22222">// lo is smallest x that P(x) = true
</FONT></I>}

</PRE>
<HR>
<ADDRESS>Generated by <A HREF="http://www.iki.fi/~mtr/genscript/">GNU Enscript 1.6.6</A>.</ADDRESS>
</BODY>
</HTML>
